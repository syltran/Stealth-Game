commit 4fe2cd827e5672f3b46fa242867152d5b5838903
Author: Sylvain Tran <sylvain.tran@etud.u-pem.fr>
Date:   Fri Jan 13 20:07:06 2023 +0100

    petites modifications dans le Main et dans Graphic

diff --git a/Graphic.c b/Graphic.c
index d599524..7217189 100644
--- a/Graphic.c
+++ b/Graphic.c
@@ -1,55 +1,296 @@
-#include "Graphic.h"
+#include "../include/Graphic.h"
 #include <stdio.h>
 
 
 /* Dessine la grille 'grid' */
 void draw_grid(const Grid *grid){
     int i, j;
+    int x, y;
     for (i = 0; i < NB_LIN; i++){
         for (j = 0; j < NB_COL; j++){
-            MLV_draw_filled_rectangle(j * SIZE_CASE, i * SIZE_CASE, SIZE_CASE, SIZE_CASE, MLV_COLOR_GRAY);
-            MLV_draw_rectangle(j * SIZE_CASE, i * SIZE_CASE, SIZE_CASE, SIZE_CASE, MLV_COLOR_GRAY50);
-            
+            x = j * SIZE_CASE;
+            y = i * SIZE_CASE;
+
+            MLV_draw_filled_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_GRAY);
+            MLV_draw_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_GRAY50);            
             switch(grid->tab[i][j]){
+                case ENTRANCE:
+                    MLV_draw_filled_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_GRAY40);
+                    break;
                 case WALL:
-                    MLV_draw_filled_rectangle(j * SIZE_CASE, i * SIZE_CASE, SIZE_CASE, SIZE_CASE, MLV_COLOR_BLACK);
+                    MLV_draw_filled_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_BLACK);
                     break;
                 case RELIC: 
-                    MLV_draw_filled_rectangle(j * SIZE_CASE, i * SIZE_CASE, SIZE_CASE, SIZE_CASE, MLV_COLOR_YELLOW1);
+                    MLV_draw_filled_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_YELLOW1);
                     break;
                 case MANA:
-                    MLV_draw_filled_circle(j * SIZE_CASE + SIZE_CASE / 2, i * SIZE_CASE + SIZE_CASE / 2, SIZE_CASE / 3, MLV_COLOR_SKY_BLUE);
-                    MLV_draw_circle(j * SIZE_CASE + SIZE_CASE / 2, i * SIZE_CASE + SIZE_CASE / 2, SIZE_CASE / 3, MLV_COLOR_SKY_BLUE);
+                    MLV_draw_filled_circle(x + SIZE_CASE / 2, y + SIZE_CASE / 2, SIZE_CASE / 4, MLV_COLOR_SKY_BLUE);
+                    MLV_draw_circle(x + SIZE_CASE / 2, y + SIZE_CASE / 2, SIZE_CASE / 4, MLV_COLOR_BLACK);
                     break;
                 default: ;
             }
+            /* Reliques prises ou détectées */
+            if (grid->tab[i][j] == RELIC_TAKEN || grid->tab[i][j] == RELIC_DETECT){
+                MLV_draw_filled_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_YELLOW4);
+                MLV_draw_line(x, y, x + SIZE_CASE, y + SIZE_CASE, MLV_COLOR_RED1);
+                MLV_draw_line(x + SIZE_CASE, y, x, y + SIZE_CASE, MLV_COLOR_RED1);
+            }
         }
     }
 }
 
+
 /* Dessine le disque 'disc' avec la couleur 'color' */
 void draw_disc(Disc disc, MLV_Color color){
     MLV_draw_filled_circle(disc.center.x, disc.center.y, disc.radius, color);
-    MLV_draw_circle(disc.center.x, disc.center.y, disc.radius, MLV_COLOR_GRAY50);
+    MLV_draw_circle(disc.center.x, disc.center.y, disc.radius, MLV_COLOR_BLACK);
 }
 
 /* Dessine le joueur 'player' */
 void draw_player(const Player *player){
-    draw_disc(player->disc, MLV_COLOR_RED);
+    int acc, inv;
+    acc = 0;
+    inv = 0;
+    if (player->comp.acceleration == USED){
+        draw_disc(player->disc, MLV_COLOR_LIGHT_GREEN);
+        acc = 1;
+    }
+    if (player->comp.invisibility == USED){
+        draw_disc(player->disc, MLV_rgba(255, 0, 0, 80)); /* Effet camouflage en réduisant la transparence */
+        inv = 1;
+    }
+    if (!acc && !inv) draw_disc(player->disc, MLV_COLOR_RED);
+}
+
+
+/* Dessine la zone de détection de rayon 'dist' de l'agent 'agent' avec la couleur 'color' */
+void draw_detect_zone(Disc agent, int dist, MLV_Color color){
+    MLV_draw_filled_circle(agent.center.x, agent.center.y, dist, color);
+    MLV_draw_circle(agent.center.x, agent.center.y, dist, MLV_COLOR_BLACK);
 }
 
 /* Dessine le gardien 'guard' */
 void draw_guard(const Guard *guard){
-    draw_disc(guard->disc, MLV_COLOR_BLUE);
+    MLV_Color color, zone;
+    if (guard->mode == NORMAL){
+        color = MLV_COLOR_BLUE2;
+        zone = MLV_rgba(191, 191, 191, 80);
+    }
+    else{ /* Mode PANIC */
+        color = MLV_COLOR_RED2;
+        zone = MLV_rgba(255, 0, 0, 80);
+    }
+    draw_detect_zone(guard->disc, guard->detection_dist * SIZE_CASE, zone);
+    draw_disc(guard->disc, color);
+}
+
+
+/* Dessine la barre de mana du joueur 'player' */
+void draw_mana_bar(const Player *player){
+    int x, y, total_width, curr_witdh; 
+    total_width = SIZE_CASE * 13; /* Largeur totale de la barre */
+    curr_witdh = player->mana * total_width / MAX_MANA; /* Progression de la barre 
+                                                           en fonction de la quantité de mana de 'player' */
+    x = SIZE_CASE;
+    y = WINDOW_HEIGHT;
+    MLV_draw_text(x, y, "Mana : %d / %d", MLV_COLOR_BLUE, player->mana, MAX_MANA);
+    MLV_draw_filled_rectangle(x, y + 15, curr_witdh, SIZE_CASE, MLV_COLOR_BLUE1);
+    MLV_draw_rectangle(x, y + 15, total_width, SIZE_CASE, MLV_COLOR_BLACK);
 }
 
+/* Dessine le nombre de reliques récupérées dans la salle 'room' */
+void draw_nb_relics_taken_in_room(const Room *room){
+    int x, y, nb;
+    nb = nb_relics_taken_in_room(&(*room));
+    x = SIZE_CASE * 15;
+    y = WINDOW_HEIGHT + 15;
+    MLV_draw_text(x, y, "Relics : %d / %d", MLV_COLOR_RED, nb, NB_RELICS);
+}
+
+
 /* Dessine la salle du jeu 'room' */
 void draw_room(const Room *room){
     int i;
+    /* Grille */
     draw_grid(&room->grid);
+    /* Joueur + Gardiens */
     draw_player(&room->player);
     for (i = 0; i < NB_GUARDS; i++){
         draw_guard(&room->guards[i]);
     }
+    /* Informations utiles en bas de la fenêtre */
+    MLV_draw_filled_rectangle(0, WINDOW_HEIGHT, WINDOW_WIDTH, SPACE, MLV_COLOR_BEIGE);
+    draw_mana_bar(&room->player);
+    draw_nb_relics_taken_in_room(&(*room));
     MLV_actualise_window();
+}
+
+
+/* Affiche un texte indiquant si le joueur a gagné ou non (selon la valeur de 'win')
+ * + le temps réalisé par celui-ci et la quantité de mana dépensée (contenus dans 'score')
+*/
+void draw_end_game(int win, const Score *score){
+    int x, y;
+    x = WINDOW_WIDTH / 2 - SIZE_CASE * 6;
+    y = SIZE_CASE + SIZE_CASE * 4;
+    if (win) MLV_draw_text(x, y, "YOU WON !", MLV_COLOR_RED);
+    else MLV_draw_text(x, y, "YOU LOST !", MLV_COLOR_RED);
+    MLV_draw_text(x, y + 30, "Time spent : %0.2f seconds", MLV_COLOR_BISQUE, score->time);
+    MLV_draw_text(x, y + 50, "Mana used : %d", MLV_COLOR_BISQUE, score->mana_used);
+    MLV_update_window();
+}
+
+
+/* Dessine les 'nb' éléments Score dans 'tab' à partir du coin Nord Ouest 'x', 'y' */
+void draw_scores(Score *tab, int nb, int x, int y){
+    int i;
+    MLV_draw_text(x, y, "Name :", MLV_COLOR_BLUE_VIOLET);
+    MLV_draw_text(x + SIZE_CASE * 9, y, "Time :", MLV_COLOR_BLUE_VIOLET);
+    MLV_draw_text(x + SIZE_CASE * 16, y, "Mana used :", MLV_COLOR_BLUE_VIOLET);
+    y += 20;
+    for (i = 0; i < nb; i++){
+        MLV_draw_text(x, y + (20 * i), "%s", MLV_COLOR_WHITE, tab[i].name);
+        MLV_draw_text(x + SIZE_CASE * 9, y + (20 * i), "%0.2fs", MLV_COLOR_WHITE, tab[i].time);
+        MLV_draw_text(x + SIZE_CASE * 16, y + (20 * i), "%d", MLV_COLOR_WHITE, tab[i].mana_used);
+    }
+}
+
+/* Dessine les classements de 'r' */
+void draw_rankings(Rankings *r){
+    int x, y;
+    x = SIZE_CASE;
+    y = WINDOW_HEIGHT / 2 + 50;
+    MLV_draw_text(x + SIZE_CASE * 4, y, "Rankings by best times :", MLV_COLOR_RED);
+    draw_scores(r->best_times, r->nb_t, x, y + 30);
+
+    x = WINDOW_WIDTH / 2 + SIZE_CASE * 4;
+    MLV_draw_text(x + SIZE_CASE * 4 , y, "Rankings by best mana used :", MLV_COLOR_RED);
+    draw_scores(r->best_mana_used, r->nb_m, x, y + 30);
+    MLV_update_window();
+}
+
+
+/* Permet au joueur d'entrer son nom 'name' de taille maximal 'size' 
+* qui sera plus tard ajouté dans le tableau de classement 
+*/
+void draw_enter_name(char *name, int size){
+    MLV_Keyboard_button key; /* Code de la touche pressée */
+    int unicode;
+    char *text;
+    int i, space;
+    int x, y;
+    i = 0; /* Sert d'indice à 'name' */
+    space = 0; /* Espace entre les différents caractères entrés au clavier par le joueur */
+    x = WINDOW_HEIGHT / 2 - SIZE_CASE * 2;
+    y = SIZE_CASE * 15;
+
+    MLV_draw_text(x, y, "Enter Name : ", MLV_COLOR_GREEN);
+    while(1){
+        MLV_actualise_window();
+        MLV_wait_keyboard(&key, NULL, &unicode);
+        if (key == MLV_KEYBOARD_RETURN) return; /* Touche entrée */
+        else if (key == MLV_KEYBOARD_BACKSPACE){ /* Touche de suppression pour revenir en arrière */
+            if (i > 0){ /* Pour éviter name[-1] */
+                i--;
+                name[i] = '\0';
+                space -= 8;
+                /* On dessine un rectangle noir sur les caractères pour les effacer */
+                MLV_draw_filled_rectangle(x + SIZE_CASE * 7 + space, y, 20, 20, MLV_COLOR_BLACK);
+            }
+        }
+        else if (i < size) { /* Pour éviter un index out of range */
+            text = MLV_convert_unicode_to_string(unicode); /* on récupère le caractère avec text.. */
+            MLV_draw_text(x + SIZE_CASE * 7 + space, y, text, MLV_COLOR_WHITE);
+            name[i] = text[0]; /* ..qu'on ajoute à 'name' */
+            free(text);
+            space += 8;
+            i++;
+        }
+    }
+}
+
+
+/* Initialisation de l'image 'image' et changement de sa taille pour l'adapter au jeu */
+int init_image(const char *image){
+    MLV_Image *img;
+    img = MLV_load_image(image);
+    if (img == NULL) return -1;
+    MLV_resize_image(img, WINDOW_WIDTH + SPACE, WINDOW_HEIGHT + SPACE);
+    MLV_draw_image(img, 0, 0);
+    return 0;
+}
+
+/* Permet d'afficher du texte avec fonte */
+int draw_text(int x, int y, char* text, int size, MLV_Color color){
+    MLV_Font *font;
+    font = MLV_load_font("img/MustardSmile.ttf", size);
+    if (font == NULL) return -1;
+    MLV_draw_text_with_font(x, y, text, font, color);
+    return 0;
+}
+
+/* Permet l'affichage du logo du jeu */
+int draw_logo(){
+    if (draw_text(WINDOW_WIDTH / 10 - 5, WINDOW_HEIGHT / 7,  "Stealth ", 68, MLV_COLOR_YELLOW2) == -1) return -1;
+    if (draw_text(WINDOW_WIDTH / 10 + 47, WINDOW_HEIGHT / 7 + 70 + 30 , " Game", 68, MLV_COLOR_YELLOW2) == -1) return -1;
+    if (draw_text(WINDOW_WIDTH / 10 - 5, WINDOW_HEIGHT / 7 ,"Stealth ", 65, MLV_COLOR_RED2) == -1) return -1;
+    if (draw_text(WINDOW_WIDTH / 10 + 47, WINDOW_HEIGHT / 7 + 70 + 30, " Game", 65, MLV_COLOR_RED2) == -1) return -1;
+    return 0;
+}
+
+/* Écrit les choix du menu dans un rectangle adapté */
+int draw_box(){
+    MLV_Font *font;
+    font = MLV_load_font("img/MustardSmile.ttf", 50);
+    if (font == NULL) return -1;
+    /* Choix pour Jouer */
+    MLV_draw_adapted_text_box_with_font(
+                X_BOX_PLAY , Y_BOX_PLAY,
+                " PLAY ",
+                font,
+                10,
+                MLV_COLOR_RED, MLV_COLOR_RED, MLV_COLOR_BLUE4,
+                MLV_TEXT_CENTER
+    );
+    /* Choix pour Quitter */
+    MLV_draw_adapted_text_box_with_font(
+                X_BOX_QUIT, Y_BOX_QUIT,
+                " QUIT ",
+                font,
+                10,
+                MLV_COLOR_YELLOW, MLV_COLOR_YELLOW, MLV_COLOR_BLUE4,
+                MLV_TEXT_CENTER
+    ); 
+    return 0;
+}
+
+/* Affiche l'intégralité du menu comprenant à l'arrière plan l'image de nom 'img_name' */
+int draw_menu(char *img_name){
+    if (init_image(img_name) == -1) return -1;
+    if (draw_logo() == -1) return -1;
+    if (draw_box() == -1) return -1;
+    MLV_actualise_window();
+    return 0;
+}
+
+
+/* Gestion de clic dans le menu. Renvoie 1 si le clic est sur Play, sinon 0 car sur Quit */
+int play(){
+    int x, y;
+    while(1){
+        MLV_get_mouse_position(&x, &y);
+        /* Clic pour Play */
+        if (MLV_get_mouse_button_state( MLV_BUTTON_LEFT ) == MLV_PRESSED ){
+            if (x > X_BOX_PLAY && x < X_BOX_PLAY + 160 && y > Y_BOX_PLAY && y < Y_BOX_PLAY + 75){
+                return 1;
+            }
+        }
+        /* Clic pour Quit */
+        if (MLV_get_mouse_button_state( MLV_BUTTON_LEFT ) == MLV_PRESSED ){
+            if (x > X_BOX_QUIT && x < X_BOX_QUIT + 160 && y > Y_BOX_QUIT && y < Y_BOX_QUIT + 75){
+                return 0;
+            }   
+        }
+        MLV_actualise_window();
+    }
 }
\ No newline at end of file
diff --git a/Main.c b/Main.c
index 2fdfe09..d855df1 100644
--- a/Main.c
+++ b/Main.c
@@ -1,6 +1,7 @@
 #define _POSIX_C_SOURCE 199309L
-#include "GameEngine.h"
-#include "Graphic.h"
+#include "../include/GameEngine.h"
+#include "../include/Graphic.h"
+#include "../include/Ranking.h"
 #include <MLV/MLV_all.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -9,14 +10,44 @@
 
 int main(){
     srand(time(NULL));
+    MLV_Music* music;
+    int quit, win;
+    struct timespec start, end;
     Room room;
+    Rankings rankings;
+    Score score;
 
+    /* Initialisation de variables */
     initialize_room(&room);
-    MLV_create_window("Game", "Game", WINDOW_WIDTH, WINDOW_HEIGHT);
+    initialize_rankings(&rankings);
+    initialize_score(&score);
+    quit = 0;
 
+    /* Fenêtre du jeu */
+    MLV_create_window("Game", "Game", WINDOW_WIDTH, WINDOW_HEIGHT + SPACE);
+
+    /* Initialisation d'une musique de fond */
+    MLV_init_audio();
+    music = MLV_load_music("sound/sound.ogg");
+    if (music == NULL) {
+        fprintf(stderr, "Error while loading sound\n");
+        exit(EXIT_FAILURE);
+    }
+    MLV_play_music(music, 1.0, -1);
+
+    /* Menu */
+    if (draw_menu("img/menu.jpg") == -1){
+        fprintf(stderr, "Error while drawing menu\n");
+        exit(EXIT_FAILURE);
+    }
+    if (!play()) exit(EXIT_SUCCESS);
+
+
+    MLV_clear_window(MLV_COLOR_BLACK);
+    clock_gettime(CLOCK_REALTIME, &start);
     /* Boucle maîtresse gérant le jeu frame par frame 
      (le programme doit faire NB_FRAMES_PER_S frames par seconde) */
-    while(1){
+    while(!quit){
         struct timespec end_time, new_time;
         double frametime, extratime;
         /* On récupère le temps en nanoseconde au début de la frame */
@@ -29,14 +60,18 @@ int main(){
         move_guards_in_room(&room);
         move_player_in_room(&room);
         absorb_manas_in_room(&room);
-        use_player_competences_in_room(&room);
+        use_player_competences_in_room(&room, &score.mana_used);
         take_relics_in_room(&room);
         manage_guards_modes_in_room(&room);
 
-
+        /* Conditions de fin de partie */
         if (player_detected_in_room(&room)){
-            printf("perdu\n"); 
-            break;
+            win = 0;
+            quit = 1;
+        }
+        if (player_mission_accomplished(&room)){
+            win = 1;
+            quit = 1;
         }
 
         /* On récupère le temps en nanoseconde à la fin de la frame */
@@ -52,7 +87,36 @@ int main(){
             MLV_wait_milliseconds((int) (extratime * 1000));
         }
     }
-    MLV_wait_seconds(100);
+    clock_gettime(CLOCK_REALTIME, &end);
+    MLV_wait_seconds(1);
+    MLV_clear_window(MLV_COLOR_BLACK);
+
+    /* Calcule du temps réalisé par le joueur */
+    score.time = time_achieved(&start, &end);
+
+    /* Affichage du résultat de la partie, du temps réalisé et de la quantité de mana dépensée */
+    draw_end_game(win, &score);
+
+    /* Si le joueur gagne, il peut entrer son nom dans le tableau des meilleurs scores */
+    if (win){
+        draw_enter_name(score.name, SIZE_NAME);
+        if (save_score("rankings.bin", &score) == -1){
+            fprintf(stderr, "Error while saving score\n");
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    /* Affichage du tableau de classement */
+    if (get_scores("rankings.bin", &rankings) == -1){
+        fprintf(stderr, "Error while getting scores\n");
+        exit(EXIT_FAILURE);
+    }
+    draw_rankings(&rankings);
+
+    MLV_wait_seconds(30);
+    MLV_stop_music();
+    MLV_free_music(music);
+    MLV_free_audio();
     MLV_free_window();
     return 0;
 }
\ No newline at end of file

commit df175978e3b2c82d0c7155b1e4c8107850ae459d
Author: Sylvain Tran <sylvain.tran@etud.u-pem.fr>
Date:   Fri Jan 13 19:17:49 2023 +0100

    Création du module Ranking pour le tableau des classements (meilleur temps + meilleur consommation de mana) ; Amélioration de l’affichage graphique ; Création des différents répertoires (bin, src, img, ect.) ; Combinaison des modules Graphic et Menu (car Menu fait partie de l’affichage graphique) ; Finalisation du projet

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..017a370
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,45 @@
+
+CC=gcc
+CFLAGS=-ansi -Wall
+LDFLAGS=-lm -lMLV
+EXEC=game
+SRC=src/
+INC=include/
+BIN=bin/
+OBJ=$(BIN)Main.o $(BIN)Direction.o $(BIN)Point.o $(BIN)Disc.o $(BIN)Player.o $(BIN)Guard.o $(BIN)Grid.o $(BIN)Terrain.o $(BIN)Collision.o $(BIN)Detection.o $(BIN)Ranking.o $(BIN)GameEngine.o $(BIN)Graphic.o
+
+$(EXEC): $(OBJ)
+	$(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)
+
+$(BIN)Main.o: $(SRC)Main.c $(INC)GameEngine.h $(INC)Graphic.h $(INC)Ranking.h
+
+$(BIN)Direction.o: $(SRC)Direction.c $(INC)Direction.h
+
+$(BIN)Point.o: $(SRC)Point.c $(INC)Point.h
+
+$(BIN)Disc.o: $(SRC)Disc.c $(INC)Disc.h $(INC)Point.h
+
+$(BIN)Player.o: $(SRC)Player.c $(INC)Player.h $(INC)Point.h $(INC)Disc.h $(INC)Direction.h $(INC)Grid.h
+
+$(BIN)Guard.o: $(SRC)Guard.c $(INC)Guard.h $(INC)Point.h $(INC)Disc.h $(INC)Direction.h $(INC)Grid.h $(INC)Player.h
+
+$(BIN)Grid.o: $(SRC)Grid.c $(INC)Grid.h
+
+$(BIN)Terrain.o: $(SRC)Terrain.c $(INC)Terrain.h $(INC)Grid.h $(INC)Point.h $(INC)Disc.h $(INC)Player.h $(INC)Guard.h
+
+$(BIN)Collision.o: $(SRC)Collision.c $(INC)Collision.h $(INC)Point.h $(INC)Disc.h $(INC)Direction.h $(INC)Grid.h $(INC)Terrain.h $(INC)Guard.h
+
+$(BIN)Detection.o: $(SRC)Detection.c $(INC)Detection.h $(INC)Point.h $(INC)Disc.h $(INC)Guard.h $(INC)Player.h $(INC)Grid.h $(INC)Terrain.h
+
+$(BIN)Ranking.o: $(SRC)Ranking.c $(INC)Ranking.h
+
+$(BIN)GameEngine.o: $(SRC)GameEngine.c $(INC)GameEngine.h $(INC)Grid.h $(INC)Player.h $(INC)Guard.h $(INC)Terrain.h $(INC)Collision.h $(INC)Detection.h
+
+$(BIN)Graphic.o: $(SRC)Graphic.c $(INC)Graphic.h $(INC)GameEngine.h $(INC)Ranking.h
+
+$(BIN)%.o: $(SRC)%.c
+	$(CC) -o $@ -c $< $(CFLAGS) $(LDFLAGS)
+
+clean:
+	rm -f $(BIN)*
+	rm $(EXEC)
diff --git a/img/MustardSmile.ttf b/img/MustardSmile.ttf
new file mode 100644
index 0000000..e898e6c
Binary files /dev/null and b/img/MustardSmile.ttf differ
diff --git a/img/menu.jpg b/img/menu.jpg
new file mode 100644
index 0000000..0721f81
Binary files /dev/null and b/img/menu.jpg differ
diff --git a/include/Collision.h b/include/Collision.h
new file mode 100644
index 0000000..97a78ab
--- /dev/null
+++ b/include/Collision.h
@@ -0,0 +1,23 @@
+#ifndef __COLLISION__
+#define __COLLISION__
+
+#include "Point.h"
+#include "Disc.h"
+#include "Direction.h"
+#include "Grid.h"
+#include "Terrain.h"
+#include "Guard.h"
+
+void determine_front_cases(Disc agent, Direction dir, int dist, Case *front, Case *front_side1, Case *front_side2);
+int risk_collide_wall(Disc agent, Direction dir, int dist, const Grid *grid);
+
+void resize_mini_coordinate(double *x);
+void resize_real_coordinate(double *x);
+int travel_limit_in_y(Disc agent, Direction dir, int dist, const Grid *grid, double *ymax);
+int travel_limit_in_x(Disc agent, Direction dir, int dist, const Grid *grid, double *xmax);
+int travel_limit(Disc agent, Direction dir, int dist, const Grid *grid, double *limit);
+
+int collide_wall(Disc *agent, Direction dir, double limit);
+int collide_guard(Guard *guard, int index, const Guard *tab, int size);
+
+#endif
\ No newline at end of file
diff --git a/include/Detection.h b/include/Detection.h
new file mode 100644
index 0000000..d44c39f
--- /dev/null
+++ b/include/Detection.h
@@ -0,0 +1,27 @@
+#ifndef __DETECTION__
+#define __DETECTION__
+
+#include "Point.h"
+#include "Disc.h"
+#include "Guard.h"
+#include "Player.h"
+#include "Grid.h"
+#include "Terrain.h"
+
+
+double position_Pa(int a, Point point_0, Point point_1);
+double position_Pb(int b, Point point_0, Point point_1);
+int p_in_segment(double p);
+double ordinate_Pa(int a, Point point_0, Point point_1);
+double abscissa_Pb(int b, Point point_0, Point point_1);
+Point x_higher(const Point point_1, const Point point_2);
+Point x_lower(const Point point_1, const Point point_2);
+Point y_higher(const Point point_1, const Point point_2);
+Point y_lower(const Point point_1, const Point point_2);
+Point copy_point(const Point point);
+Case point_to_case(double x, double y);
+int wall_between_point_guard(Point center, const Guard *guard, const Grid *grid);
+int player_in_zone(const Player *player, const Guard *guard);
+int detect_missing_relics(const Guard *guard, Grid *grid);
+
+#endif
\ No newline at end of file
diff --git a/include/Direction.h b/include/Direction.h
new file mode 100644
index 0000000..4799d3a
--- /dev/null
+++ b/include/Direction.h
@@ -0,0 +1,11 @@
+#ifndef __DIRECTION__
+#define __DIRECTION__
+
+typedef enum{
+    UP,
+    DOWN,
+    LEFT,
+    RIGHT
+} Direction; /* Représente une direction */
+
+#endif
\ No newline at end of file
diff --git a/include/Disc.h b/include/Disc.h
new file mode 100644
index 0000000..d3ad078
--- /dev/null
+++ b/include/Disc.h
@@ -0,0 +1,14 @@
+#ifndef __DISC__
+#define __DISC__
+
+#include "Point.h"
+
+typedef struct{
+    Point center; /* Coordonnées du centre */
+    int radius; /* Rayon */
+} Disc; /* Représente un disque */
+
+int superposition_between_discs(Disc d1, Disc d2);
+int point_inside_disc(Point a, Disc disc);
+
+#endif
\ No newline at end of file
diff --git a/include/GameEngine.h b/include/GameEngine.h
new file mode 100644
index 0000000..2d3b737
--- /dev/null
+++ b/include/GameEngine.h
@@ -0,0 +1,42 @@
+#ifndef __GAMEENGINE__
+#define __GAMEENGINE__
+
+#include "Grid.h"
+#include "Player.h"
+#include "Guard.h"
+#include "Terrain.h"
+#include "Collision.h"
+#include "Detection.h"
+#define NB_GUARDS 5 /* Nombre de gardiens */
+#define NB_RELICS 3 /* Nombre de reliques */
+#define NB_FRAMES_PER_S 60 /* Nombre de frames par seconde */
+
+typedef struct{
+    Grid grid;
+    Player player;
+    Guard guards[NB_GUARDS];
+} Room; /* Représente la salle du jeu rassemblant tous les objets du jeu */
+
+void initialize_room(Room *room);
+
+void move_guard(Guard *guard, int index, const Guard *tab, int size, const Grid *grid);
+void move_guards_in_room(Room *room);
+
+void move_player(Player *player, const Grid *grid, Direction pressed);
+void move_player_in_room(Room *room);
+void absorb_mana(Player *player, Grid *grid);
+void absorb_manas_in_room(Room *room);
+void use_player_competences_in_room(Room *room, int *mana_used);
+void take_relic(const Player *player, Grid *grid);
+void take_relics_in_room(Room *room);
+
+void guards_enter_panic_mode_in_room(Room *room);
+void guards_enter_normal_mode_in_room(Room *room);
+void manage_guards_modes_in_room(Room *room);
+
+int player_detected_in_room(const Room *room);
+int nb_relics_taken_in_room(const Room *room);
+int all_relics_taken_in_room(const Room *room);
+int player_mission_accomplished(const Room *room);
+
+#endif
\ No newline at end of file
diff --git a/include/Graphic.h b/include/Graphic.h
new file mode 100644
index 0000000..0ac24d3
--- /dev/null
+++ b/include/Graphic.h
@@ -0,0 +1,36 @@
+#ifndef __GRAPHIC__
+#define __GRAPHIC__
+
+#include "GameEngine.h"
+#include "Ranking.h"
+#include <MLV/MLV_all.h>
+#define WINDOW_WIDTH NB_COL * SIZE_CASE /* Largeur de la fenêtre */
+#define WINDOW_HEIGHT NB_LIN * SIZE_CASE /* Hauteur de la fenêtre */
+#define SPACE 35 /* Espace supplémentaire pour ajouter des informations utiles dans la fenêtre */
+#define X_BOX_PLAY WINDOW_WIDTH / 12 /* Coordonnée X du coin Nord-Ouest de la boite pour Play */
+#define Y_BOX_PLAY WINDOW_HEIGHT - (WINDOW_HEIGHT / 6) /* Coordonnée Y du coin Nord-Ouest de la boite pour Play */
+#define X_BOX_QUIT WINDOW_WIDTH - (WINDOW_WIDTH / 4) /* Coordonnée X du coin Nord-Ouest de la boite pour Quit */
+#define Y_BOX_QUIT WINDOW_HEIGHT - (WINDOW_HEIGHT / 6) /* Coordonnée Y du coin Nord-Ouest de la boite pour Quit */
+
+void draw_grid(const Grid *grid);
+void draw_disc(Disc disc, MLV_Color color);
+void draw_player(const Player *player);
+void draw_detect_zone(Disc agent, int dist, MLV_Color color);
+void draw_guard(const Guard *guard);
+void draw_mana_bar(const Player *player);
+void draw_nb_relics_taken_in_room(const Room *room);
+void draw_room(const Room *room);
+
+void draw_end_game(int win, const Score *score);
+void draw_scores(Score *tab, int nb, int x, int y);
+void draw_rankings(Rankings *r);
+void draw_enter_name(char *name, int size);
+
+int init_image(const char *image);
+int draw_text(int x, int y, char* text, int size, MLV_Color color);
+int draw_logo();
+int draw_box();
+int draw_menu(char *img_name);
+int play();
+
+#endif
\ No newline at end of file
diff --git a/include/Grid.h b/include/Grid.h
new file mode 100644
index 0000000..4b43b47
--- /dev/null
+++ b/include/Grid.h
@@ -0,0 +1,38 @@
+#ifndef __GRID__
+#define __GRID__
+
+#define NB_LIN 45 /* Hauteur de la grille */
+#define NB_COL 60 /* Longueur de la grille */
+#define SIZE_CASE 15 /* Longueur des côtés d'une case */
+
+typedef struct{
+    int lin, col;
+} Case; /* Représente une case de la grille */
+
+typedef enum{
+    EMPTY, /* Vide */
+    ENTRANCE, /* Entrée */
+    WALL, /* Mur */
+    GAP, /* Ouverture */
+    MANA, /* Traces de mana */
+    RELIC, /* Relique */
+    RELIC_TAKEN, /* Relique prise */
+    RELIC_DETECT /* Relique détectée */
+} InfoCase; /* Donne une information sur une case */
+
+typedef struct{
+    InfoCase tab[NB_LIN][NB_COL];
+} Grid; /* Représente la grille du jeu */
+
+void initialize_grid(Grid *grid);
+void show_grid(const Grid *grid);
+int is_empty(const Grid *grid, Case coord);
+int is_entrance(const Grid *grid, Case coord);
+int is_gap(const Grid *grid, Case coord);
+int is_wall(const Grid *grid, Case coord);
+int is_relic(const Grid *grid, Case coord);
+int is_mana(const Grid *grid, Case coord);
+int is_relic_taken(const Grid *grid, Case coord);
+int is_relic_detect(const Grid *grid, Case coord);
+
+#endif
\ No newline at end of file
diff --git a/include/Guard.h b/include/Guard.h
new file mode 100644
index 0000000..d411456
--- /dev/null
+++ b/include/Guard.h
@@ -0,0 +1,39 @@
+#ifndef __GUARD__
+#define __GUARD__
+
+#include "Point.h"
+#include "Disc.h"
+#include "Direction.h"
+#include "Grid.h"
+#include "Player.h" /* Les calculs de vitesse d'un gardien sont calqués sur le joueur et ont donc besoin de "v" */
+
+#define MIN_SPEED_NL 0.3 * V /* Vitesse minimale d'un gardien en mode normal */
+#define MAX_SPEED_NL 0.8 * V /* Vitesse maximale d'un gardien en mode normal */
+#define SPEED_PC V /* Vitesse d'un gardien en mode panique */
+#define DETECT_DIST_NL 4 /* Distance de détection d'un gardien en mode normal */
+#define DETECT_DIST_PC 6 /* Distance de détection d'un gardien en mode panique */
+#define TIME_PC 30 /* Durée du mode panique en seconde */
+
+typedef enum{
+    NORMAL, /* Mode normal */
+    PANIC /* Mode panique */
+} Mode; /* Mode du gardien */
+
+typedef struct{
+    Disc disc; /* Représentation du gardien par un disque */
+    Mode mode; /* Le mode activé */
+    Direction dir; /* Sa direction */
+    double speed; /* Sa vitesse */
+    int detection_dist; /* Distance de détection en nombre de cases */
+} Guard; /* Représente un gardien */
+
+void initialize_guard(Guard *guard);
+void enter_normal_mode(Guard *guard);
+void enter_panic_mode(Guard *guard);
+
+double random_speed(double min, double max);
+Direction random_direction();
+void change_direction_speed_guard(Guard *guard);
+void change_position_guard(Guard *guard);
+
+#endif
\ No newline at end of file
diff --git a/include/Player.h b/include/Player.h
new file mode 100644
index 0000000..16e680b
--- /dev/null
+++ b/include/Player.h
@@ -0,0 +1,46 @@
+#ifndef __PLAYER__
+#define __PLAYER__
+
+#include "Point.h"
+#include "Disc.h"
+#include "Direction.h"
+#include "Grid.h"
+
+#define V 4.4 /* Vitesse "v" sur laquelle les calculs de vitesse du joueur sont basés */
+#define INITIAL_SPEED 0.1 * V /* Vitesse initiale quand le joueur démarre ou change de direction */
+#define ACC 0.03 * V /* On accélère INITIAL_SPEED par ACC à chaque frame où la touche de direction reste enfoncée */
+#define MAX_SPEED 0.9 * V /* Vitesse maximale atteignable par le joueur */
+#define MAX_SPEED_ACC 1.2 * V /* Vitesse maximale atteignable avec la compétence Accélération */
+#define MAX_MANA 100 /* Quantité maximale de mana absorbable */
+#define INV_MANA 1 /* Quantité de mana consommée par la compétence Invisibilité à chaque frame */
+#define ACC_MANA 2 /* Quantité de mana consommée par la compétence Accélération à chaque frame */
+#define USED 1 /* Compétence utilisée */
+#define UNUSED 0 /* Compétence non utilisée */
+
+typedef struct{
+    int acceleration; /* Accélération */
+    int invisibility; /* Invisibilité */
+} Competence; /* Compétences magiques du joueur */
+
+typedef struct{
+    Disc disc; /* Représentation du joueur par un disque */
+    Direction dir; /* Sa direction */
+    double speed, max_speed; /* Sa vitesse et la vitesse maximale atteignable */
+    int mana, max_mana; /* Sa réverse de mana et la quantité maximale de mana absorbable */
+    Competence comp; /* Ses compétences */
+} Player; /* Représente le joueur */
+
+void initialize_player(Player *player);
+void change_position(Disc *agent, Direction dir, double speed);
+void change_position_player(Player *player);
+int same_direction(Direction d1, Direction d2);
+void change_direction_speed_player(Player *player, Direction pressed);
+
+void activate_acceleration(Player *player);
+void desactivate_acceleration(Player *player);
+void use_acceleration(Player *player);
+void activate_invisibility(Player *player);
+void desactivate_invisibility(Player *player);
+void use_invisibility(Player *player);
+
+#endif
\ No newline at end of file
diff --git a/include/Point.h b/include/Point.h
new file mode 100644
index 0000000..07fc3f6
--- /dev/null
+++ b/include/Point.h
@@ -0,0 +1,13 @@
+#ifndef __POINT__
+#define __POINT__
+
+typedef struct{
+    double x, y;
+} Point; /* Représente un point de coordonnées (x, y) */
+
+double distance(Point a, Point b);
+int random_int(int a, int b);
+double random_double(int a, int b);
+Point random_point(int x1, int x2, int y1, int y2);
+
+#endif
\ No newline at end of file
diff --git a/include/Ranking.h b/include/Ranking.h
new file mode 100644
index 0000000..b12b17c
--- /dev/null
+++ b/include/Ranking.h
@@ -0,0 +1,33 @@
+#ifndef __RANKING__
+#define __RANKING__
+
+#define _POSIX_C_SOURCE 199309L
+#include <stdio.h>
+#include <time.h>
+#define SIZE_NAME 10 /* Taille d'un nom rentré */
+#define MAX_S 10 /* Nombre maximal de score affiché par classement */
+
+typedef struct{
+    double time; /* Temps réalisé en seconde */
+    int mana_used; /* Quantité de mana dépensée */
+    char name[SIZE_NAME]; /* Nom rentré */
+} Score; /* Représente le score du joueur en fin de partie */
+
+typedef struct{
+    Score best_times[MAX_S]; /* Par meilleur temps */
+    Score best_mana_used[MAX_S]; /* Par meilleure consommation de mana */
+    int nb_t; /* Nombre de score déjà inscrit dans best_times */
+    int nb_m; /* Nombre de score déjà inscrit dans best_mana_used */
+} Rankings; /* Représente les classements */
+
+void initialize_score(Score *score);
+void initialize_rankings(Rankings *r);
+double time_achieved(struct timespec *start, struct timespec *end);
+void shift_right(Score *tab, int size, int index);
+void update_best_times(Rankings *r, const Score *score);
+void update_best_mana_used(Rankings *r, const Score *score);
+void update_rankings(Rankings *r, const Score *score);
+int save_score(char *name, const Score *score);
+int get_scores(char *name, Rankings *r);
+
+#endif
\ No newline at end of file
diff --git a/include/Terrain.h b/include/Terrain.h
new file mode 100644
index 0000000..b871e85
--- /dev/null
+++ b/include/Terrain.h
@@ -0,0 +1,38 @@
+#ifndef __TERRAIN__
+#define __TERRAIN__
+
+#include "Grid.h"
+#include "Point.h"
+#include "Disc.h"
+#include "Player.h"
+#include "Guard.h"
+
+#define MINSIDE 9 /* Longueur minimale des côtés des compartiments crées */
+#define LENGTH_GAP 3 /* Taille d'une ouverture : 3 cases */
+#define INITIAL_POS_X 2.0 * SIZE_CASE /* Coordonnée x de la position initiale du joueur */
+#define INITIAL_POS_Y 2.0 * SIZE_CASE /* Coordonnée y de la position initiale du joueur */
+#define MINDIST 20 * SIZE_CASE /* Distance euclidienne minimale qu'il doit y avoir entre
+                                la position initiale du joueur et la position des gardiens et des reliques */
+
+
+void generate_vertical_wall(Grid *grid, int column, int start_y, int end_y);
+void generate_horizontal_wall(Grid *grid, int line, int start_x, int end_x);
+void random_position_for_wall(int *pos, int start, int end, int *left, int *right);
+void generate_compartments(Grid *grid, int x, int start_x, int end_x, int y, int start_y, int end_y);
+
+void place_player_in_grid(Player *player);
+
+int far_enough_from_the_player(Point point, const Player *player);
+Case point_case(Point point);
+void resize_point(Point *point);
+
+void place_relics_in_grid(int nb_relics, Grid *grid, const Player *player);
+void place_manas_in_grid(Grid *grid);
+void place_random_mana_in_grid(Grid *grid);
+
+int superposition_between_guards(const Guard *guard, int index, const Guard *tab, int size);
+int in_diagonal_wall(const Guard *guard, const Grid *grid);
+int in_lateral_wall_or_gap(const Guard *guard, const Grid *grid);
+void place_guard_in_grid(Guard *guard, int index, const Guard *tab, int size, const Grid *grid, const Player *player);
+
+#endif
\ No newline at end of file
diff --git a/rankings.bin b/rankings.bin
new file mode 100644
index 0000000..e69de29
diff --git a/sound/sound.ogg b/sound/sound.ogg
new file mode 100644
index 0000000..2db39c8
Binary files /dev/null and b/sound/sound.ogg differ
diff --git a/src/Collision.c b/src/Collision.c
new file mode 100644
index 0000000..76e0016
--- /dev/null
+++ b/src/Collision.c
@@ -0,0 +1,203 @@
+#include "../include/Collision.h"
+#include <stdio.h>
+#include <math.h>
+
+
+/* Détermine et récupère les 3 cases ('front', 'front_side1' et 'front_side2') en face de l'agent 'agent' 
+ * suivant la direction du déplacement 'dir' et à une distance 'dist' de celui-ci.
+ * Par exemple,
+ * Si 'dist' = 0, les 3 cases récupérées sont celles immédiatements situées en face de l'agent 'agent'.
+ * Si 'dist' = 1, ce sont les 3 cases situées 1 case plus loin qui sont récupérées
+*/
+void determine_front_cases(Disc agent, Direction dir, int dist, Case *front, Case *front_side1, Case *front_side2){
+    Case coord; /* Case contenant le centre du disque 'agent' */
+    int offset_lin[] = {-(1 + dist), 1 + dist, 0, 0};
+    int offset_col[] = {0, 0, -(1 + dist), 1 + dist};
+    int lin, col;
+    coord = point_case(agent.center);
+
+    /* Pour Haut et Bas, les 3 cases ont la même ligne. Seule la colonne change */
+    if (dir == UP || dir == DOWN){
+        lin = coord.lin + offset_lin[dir];
+        front->lin = front_side1->lin = front_side2->lin = lin;
+        front->col = coord.col; /* Case devant */
+        front_side1->col = coord.col - 1; /* Case devant à gauche */
+        front_side2->col = coord.col + 1; /* Case devant à droite */
+    }
+
+    /* Pour Gauche et Droite, les 3 cases ont la même colonne. Seule la ligne change */
+    else if (dir == LEFT || dir == RIGHT){
+        col = coord.col + offset_col[dir];
+        front->lin = coord.lin; /* Case devant */
+        front_side1->lin = coord.lin - 1; /* Case devant en haut */
+        front_side2->lin = coord.lin + 1; /* Case devant en bas */
+        front->col = front_side1->col = front_side2->col = col;
+    }
+}
+
+/* Renvoie 1 si l'agent 'agent' risque d'entrer en collision avec un mur dans la grille 'grid' 
+ * situé à distance 'dist' de celui-ci suivant sa direction 'dir', 0 sinon 
+*/
+int risk_collide_wall(Disc agent, Direction dir, int dist, const Grid *grid){
+    Case f, f_s1, f_s2;
+    determine_front_cases(agent, dir, dist, &f, &f_s1, &f_s2);
+    return is_wall(&(*grid), f) || is_wall(&(*grid), f_s1) || is_wall(&(*grid), f_s2);
+}
+
+
+/* Redimensionne la coordonnée 'x' pour l'adapter aux dimensions "réduites" du terrain */
+void resize_mini_coordinate(double *x){
+    *x /= SIZE_CASE;
+}
+
+/* Redimensionne la coordonnée 'x' pour l'adapter aux dimensions "réelles" du terrain */
+void resize_real_coordinate(double *x){
+    *x *= SIZE_CASE;
+}
+
+
+/* Renvoie 1 si une limite de déplacement en y a été calculée pour l'agent 'agent', 0 sinon.
+ * Si c'est le cas, cette limite est récupérée avec 'ymax'
+*/
+int travel_limit_in_y(Disc agent, Direction dir, int dist, const Grid *grid, double *ymax){
+    Case f, f_s1, f_s2; /* Les 3 cases de devant à distance 'dist' du disque 'agent' suivant 'dir' */
+    Case coord; /* Case contenant le centre du disque 'agent' */
+    int x, y; /* Coordonnées du coin en haut à gauche de 'coord' */
+    double x0; /* Coordonnée x du centre du disque 'agent' */
+    double mid; /* Coordonnée du milieu du segment [⌊x0⌋, ⌊x0⌋ + 1] */
+    double height; /* Hauteur (du triangle) à additionner ou à soustraire à 'ymax' */
+    int limit; /* limit = 1 si une limite de déplacement a été calculée */
+    
+    determine_front_cases(agent, dir, dist, &f, &f_s1, &f_s2);
+    coord = point_case(agent.center);
+    x = coord.col;
+    y = coord.lin;
+    x0 = agent.center.x;
+    mid = x + (1 / (double) 2);
+    resize_real_coordinate(&mid);
+    limit = 0;
+
+    /* 1ER Cas: */
+    if (is_wall(&(*grid), f_s1) && x0 < mid){
+        resize_mini_coordinate(&x0);
+        height = sqrt(1 / (double)4 - pow(x0 - x, 2));
+        
+        if (dir == DOWN) *ymax = y + 1 - height;
+        else if (dir == UP) *ymax = y + height;
+        limit = 1;
+    }
+    /* 2ND Cas: */
+    if (is_wall(&(*grid), f_s2) && x0 > mid){
+        resize_mini_coordinate(&x0);
+        height = sqrt(1 / (double)4 - pow(x + 1 - x0, 2));
+
+        if (dir == DOWN) *ymax = y + 1 - height;
+        else if (dir == UP) *ymax = y + height;
+        limit = 1;
+    }
+    /* 3ÈME Cas: */
+    if (is_wall(&(*grid), f)){
+        *ymax = y + (1 / (double) 2);
+        limit = 1;
+    }
+    resize_real_coordinate(&(*ymax));
+    if (limit) return 1;
+    return 0;
+}
+
+/* Renvoie 1 si une limite de déplacement en x a été calculée pour l'agent 'agent', 0 sinon.
+ * Si c'est le cas, cette limite est récupérée avec 'xmax'
+*/
+int travel_limit_in_x(Disc agent, Direction dir, int dist, const Grid *grid, double *xmax){
+    Case f, f_s1, f_s2; /* Les 3 cases de devant à distance 'dist' du disque 'agent' suivant 'dir' */
+    Case coord; /* Case contenant le centre du disque 'agent' */
+    int x, y; /* Coordonnées du coin en haut à gauche de 'coord' */
+    double y0; /* Coordonnée y du centre du disque 'agent' */
+    double mid; /* Coordonnée du milieu du segment [⌊y0⌋, ⌊y0⌋ + 1] */
+    double height; /* Hauteur (du triangle) à additionner ou à soustraire à 'xmax' */
+    int limit; /* limit = 1 si une limite de déplacement a été calculée */
+
+    determine_front_cases(agent, dir, dist, &f, &f_s1, &f_s2);
+    coord = point_case(agent.center);
+    x = coord.col;
+    y = coord.lin;
+    y0 = agent.center.y;
+    mid = y + (1 / (double) 2);
+    resize_real_coordinate(&mid);
+    limit = 0;
+
+    /* 1ER Cas: */
+    if (is_wall(&(*grid), f_s1) && y0 < mid){
+        resize_mini_coordinate(&y0);
+        height = sqrt(1 / (double)4 - pow(y0 - y, 2));
+
+        if (dir == RIGHT) *xmax = x + 1 - height;
+        else if (dir == LEFT) *xmax = x + height;
+        limit = 1;
+    }
+    /* 2ND Cas: */
+    if (is_wall(&(*grid), f_s2) && y0 > mid){
+        resize_mini_coordinate(&y0);
+        height = sqrt(1 / (double)4 - pow(y + 1 - y0, 2));
+
+        if (dir == RIGHT) *xmax = x + 1 - height;
+        else if (dir == LEFT) *xmax = x + height;
+        limit = 1;
+    }
+    /* 3ÈME Cas: */
+    if (is_wall(&(*grid), f)){
+       *xmax = x + (1 / (double) 2);
+        limit = 1;
+    }
+    resize_real_coordinate(&(*xmax));
+    if (limit) return 1;
+    return 0;
+}
+
+/* Renvoie 1 si une limite de déplacement (en x ou en y suivant
+ * la direction du déplacement 'dir') a été calculée pour l'agent 'agent', 0 sinon.
+ * Si c'est le cas, cette limite est récupérée avec 'limit'
+*/
+int travel_limit(Disc agent, Direction dir, int dist, const Grid *grid, double *limit){
+    if (dir == UP || dir == DOWN){
+        if (travel_limit_in_y(agent, dir, dist, &(*grid), &(*limit))) return 1;
+    }
+    else if (dir == LEFT || dir == RIGHT){
+        if (travel_limit_in_x(agent, dir, dist, &(*grid), &(*limit))) return 1;
+    }
+    return 0;
+}
+
+
+/* Renvoie 1 (0 sinon) si l'agent 'agent' est entré en collision avec un mur dans la direction 'dir' 
+ * c'est-à-dire si l'une de ces coordonnées a dépassée la limite qui lui a été imposée par 'limit' 
+*/
+int collide_wall(Disc *agent, Direction dir, double limit){
+    if ((dir == UP && agent->center.y < limit) || (dir == DOWN && agent->center.y > limit)){
+        agent->center.y = limit;
+        return 1;
+    }
+    else if ((dir == LEFT && agent->center.x < limit) || (dir == RIGHT && agent->center.x > limit)){
+        agent->center.x = limit;
+        return 1;
+    }
+    return 0;
+}
+
+/* Renvoie 1 si le gardien 'guard' est entré en collision avec un autre gardien dans 'tab' de taille 'size', 0 sinon.
+ * 'index' est l'indice du gardien 'guard' dans le tableau 'tab'
+*/
+int collide_guard(Guard *guard, int index, const Guard *tab, int size){
+    double x0, y0;
+    int collide; /* = 1 si le gardien 'guard' entre en collision avec un autre gardien dans 'tab' */
+    x0 = guard->disc.center.x;
+    y0 = guard->disc.center.y;
+    collide = 0;
+
+    change_position_guard(&(*guard));
+    if (superposition_between_guards(&(*guard), index, tab, size)) collide = 1;
+    guard->disc.center.x = x0; /* 'guard' récupère son ancienne coordonnée x */
+    guard->disc.center.y = y0; /* 'guard' récupère son ancienne coordonnée y */
+    if (collide) return 1;
+    return 0;
+}
diff --git a/src/Detection.c b/src/Detection.c
new file mode 100644
index 0000000..4aac8e9
--- /dev/null
+++ b/src/Detection.c
@@ -0,0 +1,147 @@
+#include "../include/Detection.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+
+/* calcule la position relative d'un point Pa par raport à l'abscisse (x = a) */
+double position_Pa(int a, Point point_0, Point point_1 ){
+    return (a - point_1.x ) / (point_0.x - point_1.x);
+}
+
+/* calcule la position relative d'un point Pb par raport à l'ordonnée (y = b) */
+double position_Pb(int b, Point point_0, Point point_1 ){
+    return (b - point_1.y ) / (point_0.y - point_1.y);
+}
+
+/* vérification : 1 si la position relative appartient au segment [P0,P1] sinon 0 */
+int p_in_segment(double p){
+    return (p >= 0 && p <= 1);
+}
+
+/* calcule de l'ordonnée(y) du point Pa */
+double ordinate_Pa(int a, Point point_0, Point point_1 ){ 
+    return (point_1.y + ((point_0.y - point_1.y) / (point_0.x - point_1.x))* (a - point_1.x));
+}
+
+/* calcule de l'abscisse(x) du point Pb */
+double abscissa_Pb(int b, Point point_0, Point point_1 ){ 
+    return (point_1.x + ((point_0.x - point_1.x) / (point_0.y - point_1.y))* (b - point_1.y));
+}
+
+
+/* trouve le point qu'a le x plus petit (le plus haut) */
+Point x_higher(const Point point_1, const Point point_2){
+    return (point_1.x < point_2.x)? point_1 : point_2;
+}
+
+/* trouve le point qu'a le x plus grand (le plus bas) */
+Point x_lower(const Point point_1, const Point point_2){
+    return (point_1.x < point_2.x)? point_2 : point_1;
+}
+
+/* trouve le point qu'a le y plus petit (le plus haut) */
+Point y_higher(const Point point_1, const Point point_2){
+    return (point_1.y < point_2.y)? point_1 : point_2;
+}
+
+/* trouve le point qu'a le y plus grand (le plus bas) */
+Point y_lower(const Point point_1, const Point point_2){
+    return (point_1.y < point_2.y)? point_2 : point_1;
+}
+
+/* copie un point dans un nouveau point */
+Point copy_point(const Point point){
+    Point p;
+    p.x = point.x;
+    p.y = point.y;
+    return p;
+}
+
+/* case traversée à partir d'un point de croisement des droites avec un coté d'un carré par le segment [po, p1] */
+Case point_to_case(double x, double y){
+    Case c;
+    c.col = floor(x / SIZE_CASE);
+    c.lin = floor(y / SIZE_CASE);    
+    return c;
+}
+
+/*p0 = 'center' et p1 = centre du gardien 'guard'
+  1- trouve les points de croisement entre le segment [p0, p1] avec les axes
+  2- les convertir en case + case adjacente
+  3- renvoie 1 si l'une de ces cases est un mur, sinon 0 */
+int wall_between_point_guard(Point center, const Guard *guard, const Grid *grid){
+    int i, j;
+    double pa, ya, pb, yb;
+    Point point_highest, point_lower;
+
+    /* les points du croisement entre abscisse et segment x = a (= i) */
+    point_highest = copy_point( x_higher(center, guard->disc.center));
+    point_lower = copy_point(x_lower(center, guard->disc.center));
+
+    for ( i = floor(point_highest.x); i < floor(point_lower.x) + 1; i++ ){
+        pa = position_Pa(i , point_highest, point_lower);
+        if( p_in_segment(pa) ){
+            ya = ordinate_Pa( i, point_highest, point_lower );
+            /* si une case adjacente du point est mur */
+            if(is_wall(grid, point_to_case(i, ya)) 
+                || is_wall(grid, point_to_case(i - 1, ya))){
+                return 1;
+            }
+        }
+    }
+    /* les points du croisement entre ordonnée et segment y = b (= j) */
+    point_highest = copy_point( y_higher(center, guard->disc.center));
+    point_lower = copy_point(y_lower(center, guard->disc.center));
+    for ( j = floor(point_highest.y); j < floor(point_lower.y) + 1 ; j++ ){
+        pb = position_Pb(j , point_highest, point_lower);
+        if( p_in_segment(pb)){
+            yb = abscissa_Pb(j , point_highest, point_lower);
+            /* si une case adjacente du point est mur */
+            if(is_wall(grid, point_to_case(yb, j)) 
+                || is_wall(grid, point_to_case(yb, j - 1))){
+                    return 1;
+            }
+        }
+    }
+    return 0;
+}
+
+/* vérifie si le centre de player est dans la zone de détection du guard */
+int player_in_zone(const Player *player, const Guard *guard){
+    double dist; /* distance entre le centre du player et le centre du guard */
+    dist = distance(player->disc.center, guard->disc.center) ;
+    if (dist <= ((guard->detection_dist) * SIZE_CASE)){
+        return 1;
+    }
+    return 0;
+}
+
+/* renvoie 1 si le gardien 'guard' détecte qu'une relique a disparu dans la grille, sinon 0 */
+int detect_missing_relics(const Guard *guard, Grid *grid){
+    int i, j;
+    Disc disc; /* disque avec pour rayon la distance de détection du gardien */
+    Point middle;
+
+    disc.center = guard->disc.center;
+    disc.radius = guard->detection_dist * SIZE_CASE;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            /* pour chaque case, on calcule les coordonnées du milieu dans un point */
+            Case coord = {i, j};
+            middle.x = coord.col + (1 / (double) 2);
+            middle.y = coord.lin + (1 / (double) 2);
+            resize_point(&middle);
+            if (point_inside_disc(middle, disc)){
+                if (!wall_between_point_guard(middle, &(*guard), &(*grid))){
+                    if (is_relic_taken(&(*grid), coord)){
+                        /* on met cette relique comme étant déjà détectée */
+                        grid->tab[coord.lin][coord.col] = RELIC_DETECT;
+                        return 1;
+                    }
+                }
+            }
+        }
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/src/Direction.c b/src/Direction.c
new file mode 100644
index 0000000..dddf472
--- /dev/null
+++ b/src/Direction.c
@@ -0,0 +1 @@
+#include "../include/Direction.h"
\ No newline at end of file
diff --git a/src/Disc.c b/src/Disc.c
new file mode 100644
index 0000000..064ef33
--- /dev/null
+++ b/src/Disc.c
@@ -0,0 +1,13 @@
+#include "../include/Disc.h"
+#include <stdio.h>
+
+
+/* Renvoie 1 si les disques 'd1' et 'd2' se touchent ou se superposent, 0 sinon */
+int superposition_between_discs(Disc d1, Disc d2){
+    return distance(d1.center, d2.center) - d1.radius - d2.radius <= 0;
+}
+
+/* Renvoie 1 si le point 'a' est à l'intérieur du disque 'disc', 0 sinon */
+int point_inside_disc(Point a, Disc disc){
+    return distance(a, disc.center) < disc.radius;
+}
\ No newline at end of file
diff --git a/src/GameEngine.c b/src/GameEngine.c
new file mode 100644
index 0000000..a0616b8
--- /dev/null
+++ b/src/GameEngine.c
@@ -0,0 +1,271 @@
+#include "../include/GameEngine.h"
+#include <MLV/MLV_all.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+
+/* Initialise la salle 'room' */
+void initialize_room(Room *room){
+    int i;
+    /* Grille */
+    initialize_grid(&room->grid);
+    generate_compartments(&room->grid, NB_COL - 2, 1, NB_COL - 2, NB_LIN - 2, 1, NB_LIN - 2);
+
+    /* Joueur */
+    initialize_player(&room->player);
+    place_player_in_grid(&room->player);
+
+    /* Reliques */
+    place_relics_in_grid(NB_RELICS, &room->grid, &room->player);
+
+    /* Gardiens */
+    for (i = 0; i < NB_GUARDS; i++){
+        initialize_guard(&room->guards[i]);
+        place_guard_in_grid(&room->guards[i], i, room->guards, NB_GUARDS, &room->grid, &room->player);
+    }
+
+    /* Manas */
+    place_manas_in_grid(&room->grid);
+}
+
+
+/* Déplace le gardien 'guard' dans la grille 'grid' en prenant en compte les autres gardiens dans 'tab' de taille 'size'.
+ * 'index' est l'indice du gardien 'guard' dans le tableau 'tab'
+*/
+void move_guard(Guard *guard, int index, const Guard *tab, int size, const Grid *grid){
+    int dist; /* La distance entre le gardien 'guard' et les 3 murs face à lui
+               suivant sa direction, dont il cherche à éviter la collision */
+    double limit; /* Limite de déplacement (en x ou y) */
+    dist = 0;
+
+    if (collide_guard(&(*guard), index, tab, size)){
+        change_direction_speed_guard(&(*guard));
+        return;
+    }
+
+    /* On veut qu'un gardien en mode panique change de direction si un mur est à une case de distance
+     (donc pas directement devant lui mais 1 case plus loin) */
+    if (guard->mode == PANIC && !risk_collide_wall(guard->disc, guard->dir, 0, &(*grid))){
+        dist = 1;
+    }
+
+    if (travel_limit(guard->disc, guard->dir, dist, &(*grid), &limit)){
+        /* Si une limite de déplacement a été calculée, 
+         on fait en sorte que le gardien ne dépasse pas cette limite */
+        change_position_guard(&(*guard));
+        if (collide_wall(&guard->disc, guard->dir, limit)){
+            change_direction_speed_guard(&(*guard));
+            return;
+        }
+    }
+    else change_position_guard(&(*guard));
+    
+    /* 1 chance sur 50 de changer de direction et de vitesse à chaque frame */
+    if (rand() % 50 == 1) change_direction_speed_guard(&(*guard));
+}
+
+/* Déplace les gardiens dans la salle 'room' */
+void move_guards_in_room(Room *room){
+    int i;
+    for (i = 0; i < NB_GUARDS; i++){
+        move_guard(&room->guards[i], i, room->guards, NB_GUARDS, &room->grid);
+    }
+}
+
+
+/* Déplace le joueur 'player' dans la grille 'grid' suivant la direction choisie 'pressed' */
+void move_player(Player *player, const Grid *grid, Direction pressed){
+    double limit; /* Limite de déplacement (en x ou y) */
+
+    change_direction_speed_player(&(*player), pressed);
+    if (travel_limit(player->disc, player->dir, 0, &(*grid), &limit)){
+        /* Fait en sorte que le joueur ne rentre pas en collision avec un mur */
+        change_position_player(&(*player));
+        collide_wall(&player->disc, player->dir, limit);
+    }
+    else change_position_player(&(*player));
+}
+
+/* Renvoie 1 si la touche 'key' du clavier a été pressée, 0 sinon */
+static int key_pressed(MLV_Keyboard_button key){
+    return MLV_get_keyboard_state(key) == MLV_PRESSED;
+}
+
+/* Déplace le joueur dans la salle 'room' avec les touches z, q, s, d du clavier */
+void move_player_in_room(Room *room){
+    int zqsd;
+    zqsd = 0;
+    if (key_pressed(SDLK_z)){ /* Touche z */
+        move_player(&room->player, &room->grid, UP);
+        zqsd = 1;
+    }
+    if (key_pressed(SDLK_q)){ /* Touche q */
+        move_player(&room->player, &room->grid, LEFT);
+        zqsd = 1;
+    }
+    if (key_pressed(SDLK_s)){ /* Touche s */
+        move_player(&room->player, &room->grid, DOWN);
+        zqsd = 1;
+    }
+    if (key_pressed(SDLK_d)){ /* Touche d */
+        move_player(&room->player, &room->grid, RIGHT);
+        zqsd = 1;
+    }
+    if (!zqsd) room->player.speed = INITIAL_SPEED;
+}
+
+
+/* Permet au joueur 'player' d'absorber une trace de mana dans la grille 'grid' */
+void absorb_mana(Player *player, Grid *grid){
+    Case coord;
+    coord = point_case(player->disc.center);
+    if (player->disc.center.x != INITIAL_POS_X || player->disc.center.y != INITIAL_POS_Y){
+        if (is_mana(&(*grid), coord) && player->mana < player->max_mana){
+            grid->tab[coord.lin][coord.col] = EMPTY;
+            player->mana += 1;
+        }
+    }
+}
+
+/* Permet d'absorber les traces de mana dans la salle 'room' */
+void absorb_manas_in_room(Room *room){
+    absorb_mana(&room->player, &room->grid);
+}
+
+
+/* Permet d'utiliser les compétences du joueur dans la salle 'room'.
+ * La quantité de mana dépensée pour l'usage de ces compétences est ajoutée à 'mana_used'
+*/
+void use_player_competences_in_room(Room *room, int *mana_used){
+    int acc, inv;
+    int i, prev_mana, consume;
+    acc = 0;
+    inv = 0;
+    prev_mana = room->player.mana; /* Ancienne quantité de mana */
+
+    if (key_pressed(SDLK_LSHIFT) || key_pressed(SDLK_RSHIFT)){ /* Touche shift gauche ou droit */
+        activate_acceleration(&room->player);
+        use_acceleration(&room->player);
+        acc = 1; 
+    }
+    if (key_pressed(SDLK_SPACE)){ /* Touche espace */
+        activate_invisibility(&room->player);
+        use_invisibility(&room->player);  
+        inv = 1;
+    }
+    if (!acc) desactivate_acceleration(&room->player);
+    if (!inv) desactivate_invisibility(&room->player);
+
+    /* On calcule la quantité de mana consommée */
+    consume = prev_mana - room->player.mana;
+    *mana_used += consume;
+    /* On fait retourner cette quantité de mana sur des tuiles aléatoires
+     et dont les traces de mana avaient été absorbée */
+    for (i = 0; i < consume; i++){
+        place_random_mana_in_grid(&room->grid);
+    }
+}
+
+
+/* Permet au joueur 'player' de récupérer une relique dans la grille 'grid' */
+void take_relic(const Player *player, Grid *grid){
+    Case coord;
+    coord = point_case(player->disc.center);
+    if (is_relic(&(*grid), coord)){
+        grid->tab[coord.lin][coord.col] = RELIC_TAKEN;
+    }
+}
+
+/* Permet de récupérer les reliques dans la salle 'room' */
+void take_relics_in_room(Room *room){
+    take_relic(&room->player, &room->grid);
+}
+
+
+/* Fait entrer les gardiens de la salle 'room' en mode panique */
+void guards_enter_panic_mode_in_room(Room *room){
+    int i;
+    for (i = 0; i < NB_GUARDS; i++){
+        enter_panic_mode(&room->guards[i]);
+    }
+}
+
+/* Fait entrer les gardiens de la salle 'room' en mode normal */
+void guards_enter_normal_mode_in_room(Room *room){
+    int i;
+    for (i = 0; i < NB_GUARDS; i++){
+        enter_normal_mode(&room->guards[i]);
+    }
+}
+
+/* Gère les modes des gardiens dans la salle 'room' */
+void manage_guards_modes_in_room(Room *room){
+    int i;
+    static int cmpt, panic = 0;
+
+    for (i = 0; i < NB_GUARDS; i++){
+        /* Si un gardien voit qu'une relique a disparu, on fait entrer tous les gardiens en mode panique */
+        if (detect_missing_relics(&room->guards[i], &room->grid)){
+            guards_enter_panic_mode_in_room(&(*room));
+            panic = 1; /* Mode panique activé */
+            cmpt = 0; /* On initialise une sorte de chrono */
+        }
+    }
+    /* Si le mode panique est activé, on laisse tourner le chrono */
+    if (panic){
+        cmpt++;
+        /* Après une certaine durée, les gardiens reviennent en mode normal */
+        /* (si NB_FRAMES_PER_S = 60, 30 secondes équivaut à 1800 tours de boucle du while dans le main) */
+        if (cmpt >= NB_FRAMES_PER_S * TIME_PC){
+            guards_enter_normal_mode_in_room(&(*room));
+            panic = 0;
+        }
+    }
+}
+
+
+/* Renvoie 1 si le joueur est détecté par un gardien dans la salle 'room', 0 sinon */
+int player_detected_in_room(const Room *room){
+    int n;
+    for (n = 0; n < NB_GUARDS ; n++){
+        /* Si le joueur est directement visible par un gardien et que sa compétence Invisibilité est désactivée
+           alors le joueur perd et la partie se termine */
+        if(!wall_between_point_guard(room->player.disc.center, &room->guards[n], &room->grid)
+            && player_in_zone(&room->player, &room->guards[n]) && room->player.comp.invisibility == UNUSED){
+                return 1;
+        }
+    }
+    return 0;
+}
+
+
+/* Renvoie le nombre de reliques récupérées dans la salle 'room' */
+int nb_relics_taken_in_room(const Room *room){
+    int i, j, nb;
+    nb = 0;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            Case coord = {i, j};
+            /* Si une relique a été détectée c'est qu'elle a bien été récupérée avant */
+            if (is_relic_taken(&room->grid, coord) || is_relic_detect(&room->grid, coord)) nb++;
+        }
+    }
+    return nb;
+}
+
+/* Renvoie 1 si toutes les reliques de la salle 'room' ont été récupérées, 0 sinon */
+int all_relics_taken_in_room(const Room *room){
+    return nb_relics_taken_in_room(&(*room)) == NB_RELICS;
+}
+
+/* Renvoie 1 si le joueur a accompli sa mission :
+* celui d'infiltrer la salle 'room', de revenir à l'entrée avec toutes les reliques sans être détecté par les gardiens 
+*/
+int player_mission_accomplished(const Room *room){
+    Case coord;
+    coord = point_case(room->player.disc.center);
+    if (is_entrance(&room->grid, coord) && (coord.col == 1 && coord.lin == 1)){
+        if (all_relics_taken_in_room(&(*room))) return 1;
+    }
+    return 0;
+}
diff --git a/src/Graphic.c b/src/Graphic.c
new file mode 100644
index 0000000..4092344
--- /dev/null
+++ b/src/Graphic.c
@@ -0,0 +1,295 @@
+#include "../include/Graphic.h"
+#include <stdio.h>
+
+
+/* Dessine la grille 'grid' */
+void draw_grid(const Grid *grid){
+    int i, j;
+    int x, y;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            x = j * SIZE_CASE;
+            y = i * SIZE_CASE;
+
+            MLV_draw_filled_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_GRAY);
+            MLV_draw_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_GRAY50);            
+            switch(grid->tab[i][j]){
+                case ENTRANCE:
+                    MLV_draw_filled_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_GRAY40);
+                    break;
+                case WALL:
+                    MLV_draw_filled_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_BLACK);
+                    break;
+                case RELIC: 
+                    MLV_draw_filled_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_YELLOW1);
+                    break;
+                case MANA:
+                    MLV_draw_filled_circle(x + SIZE_CASE / 2, y + SIZE_CASE / 2, SIZE_CASE / 4, MLV_COLOR_SKY_BLUE);
+                    MLV_draw_circle(x + SIZE_CASE / 2, y + SIZE_CASE / 2, SIZE_CASE / 4, MLV_COLOR_BLACK);
+                    break;
+                default: ;
+            }
+            /* Reliques prises ou détectées */
+            if (grid->tab[i][j] == RELIC_TAKEN || grid->tab[i][j] == RELIC_DETECT){
+                MLV_draw_filled_rectangle(x, y, SIZE_CASE, SIZE_CASE, MLV_COLOR_YELLOW4);
+                MLV_draw_line(x, y, x + SIZE_CASE, y + SIZE_CASE, MLV_COLOR_RED1);
+                MLV_draw_line(x + SIZE_CASE, y, x, y + SIZE_CASE, MLV_COLOR_RED1);
+            }
+        }
+    }
+}
+
+
+/* Dessine le disque 'disc' avec la couleur 'color' */
+void draw_disc(Disc disc, MLV_Color color){
+    MLV_draw_filled_circle(disc.center.x, disc.center.y, disc.radius, color);
+    MLV_draw_circle(disc.center.x, disc.center.y, disc.radius, MLV_COLOR_BLACK);
+}
+
+/* Dessine le joueur 'player' */
+void draw_player(const Player *player){
+    int acc, inv;
+    acc = 0;
+    inv = 0;
+    if (player->comp.acceleration == USED){
+        draw_disc(player->disc, MLV_COLOR_LIGHT_GREEN);
+        acc = 1;
+    }
+    if (player->comp.invisibility == USED){
+        draw_disc(player->disc, MLV_rgba(255, 0, 0, 80)); /* Effet camouflage en réduisant la transparence */
+        inv = 1;
+    }
+    if (!acc && !inv) draw_disc(player->disc, MLV_COLOR_RED);
+}
+
+
+/* Dessine la zone de détection de rayon 'dist' de l'agent 'agent' avec la couleur 'color' */
+void draw_detect_zone(Disc agent, int dist, MLV_Color color){
+    MLV_draw_filled_circle(agent.center.x, agent.center.y, dist, color);
+    MLV_draw_circle(agent.center.x, agent.center.y, dist, MLV_COLOR_BLACK);
+}
+
+/* Dessine le gardien 'guard' */
+void draw_guard(const Guard *guard){
+    MLV_Color color, zone;
+    if (guard->mode == NORMAL){
+        color = MLV_COLOR_BLUE2;
+        zone = MLV_rgba(191, 191, 191, 80);
+    }
+    else{ /* Mode PANIC */
+        color = MLV_COLOR_RED2;
+        zone = MLV_rgba(255, 0, 0, 80);
+    }
+    draw_detect_zone(guard->disc, guard->detection_dist * SIZE_CASE, zone);
+    draw_disc(guard->disc, color);
+}
+
+
+/* Dessine la barre de mana du joueur 'player' */
+void draw_mana_bar(const Player *player){
+    int x, y, total_width, curr_witdh; 
+    total_width = SIZE_CASE * 13; /* Largeur totale de la barre */
+    curr_witdh = player->mana * total_width / MAX_MANA; /* Progression de la barre 
+                                                           en fonction de la quantité de mana de 'player' */
+    x = SIZE_CASE;
+    y = WINDOW_HEIGHT;
+    MLV_draw_text(x, y, "Mana : %d / %d", MLV_COLOR_BLUE, player->mana, MAX_MANA);
+    MLV_draw_filled_rectangle(x, y + 15, curr_witdh, SIZE_CASE, MLV_COLOR_BLUE1);
+    MLV_draw_rectangle(x, y + 15, total_width, SIZE_CASE, MLV_COLOR_BLACK);
+}
+
+/* Dessine le nombre de reliques récupérées dans la salle 'room' */
+void draw_nb_relics_taken_in_room(const Room *room){
+    int x, y, nb;
+    nb = nb_relics_taken_in_room(&(*room));
+    x = SIZE_CASE * 15;
+    y = WINDOW_HEIGHT + 15;
+    MLV_draw_text(x, y, "Relics : %d / %d", MLV_COLOR_RED, nb, NB_RELICS);
+}
+
+
+/* Dessine la salle du jeu 'room' */
+void draw_room(const Room *room){
+    int i;
+    /* Grille */
+    draw_grid(&room->grid);
+    /* Joueur + Gardiens */
+    draw_player(&room->player);
+    for (i = 0; i < NB_GUARDS; i++){
+        draw_guard(&room->guards[i]);
+    }
+    /* Informations utiles en bas de la fenêtre */
+    MLV_draw_filled_rectangle(0, WINDOW_HEIGHT, WINDOW_WIDTH, SPACE, MLV_COLOR_BEIGE);
+    draw_mana_bar(&room->player);
+    draw_nb_relics_taken_in_room(&(*room));
+    MLV_actualise_window();
+}
+
+
+/* Affiche un texte indiquant si le joueur a gagné ou non (selon la valeur de 'win')
+ * + le temps réalisé par celui-ci et la quantité de mana dépensée (contenus dans 'score')
+*/
+void draw_end_game(int win, const Score *score){
+    int x, y;
+    x = WINDOW_WIDTH / 2 - SIZE_CASE * 6;
+    y = SIZE_CASE + SIZE_CASE * 4;
+    if (win) MLV_draw_text(x, y, "YOU WON !", MLV_COLOR_RED);
+    else MLV_draw_text(x, y, "YOU LOST !", MLV_COLOR_RED);
+    MLV_draw_text(x, y + 30, "Time spent : %0.2f seconds", MLV_COLOR_BISQUE, score->time);
+    MLV_draw_text(x, y + 50, "Mana used : %d", MLV_COLOR_BISQUE, score->mana_used);
+    MLV_update_window();
+}
+
+
+/* Dessine les 'nb' éléments Score dans 'tab' à partir du coin Nord Ouest 'x', 'y' */
+void draw_scores(Score *tab, int nb, int x, int y){
+    int i;
+    MLV_draw_text(x, y, "Name :", MLV_COLOR_BLUE_VIOLET);
+    MLV_draw_text(x + SIZE_CASE * 9, y, "Time :", MLV_COLOR_BLUE_VIOLET);
+    MLV_draw_text(x + SIZE_CASE * 16, y, "Mana used :", MLV_COLOR_BLUE_VIOLET);
+    y += 20;
+    for (i = 0; i < nb; i++){
+        MLV_draw_text(x, y + (20 * i), "%s", MLV_COLOR_WHITE, tab[i].name);
+        MLV_draw_text(x + SIZE_CASE * 9, y + (20 * i), "%0.2fs", MLV_COLOR_WHITE, tab[i].time);
+        MLV_draw_text(x + SIZE_CASE * 16, y + (20 * i), "%d", MLV_COLOR_WHITE, tab[i].mana_used);
+    }
+}
+
+/* Dessine les classements de 'r' */
+void draw_rankings(Rankings *r){
+    int x, y;
+    x = SIZE_CASE;
+    y = WINDOW_HEIGHT / 2 + 50;
+    MLV_draw_text(x + SIZE_CASE * 4, y, "Rankings by best times :", MLV_COLOR_RED);
+    draw_scores(r->best_times, r->nb_t, x, y + 30);
+
+    x = WINDOW_WIDTH / 2 + SIZE_CASE * 4;
+    MLV_draw_text(x + SIZE_CASE * 4 , y, "Rankings by best mana used :", MLV_COLOR_RED);
+    draw_scores(r->best_mana_used, r->nb_m, x, y + 30);
+    MLV_update_window();
+}
+
+
+/* Permet au joueur d'entrer son nom 'name' de taille maximal 'size' 
+* qui sera plus tard ajouté dans le tableau de classement 
+*/
+void draw_enter_name(char *name, int size){
+    MLV_Keyboard_button key; /* Code de la touche pressée */
+    int unicode;
+    char *text;
+    int i, space;
+    int x, y;
+    i = 0; /* Sert d'indice à 'name' */
+    space = 0; /* Espace entre les différents caractères entrés au clavier par le joueur */
+    x = WINDOW_HEIGHT / 2 - SIZE_CASE * 2;
+    y = SIZE_CASE * 15;
+
+    MLV_draw_text(x, y, "Enter Name : ", MLV_COLOR_GREEN);
+    while(1){
+        MLV_actualise_window();
+        MLV_wait_keyboard(&key, NULL, &unicode);
+        if (key == MLV_KEYBOARD_RETURN) return; /* Touche entrée */
+        else if (key == MLV_KEYBOARD_BACKSPACE){ /* Touche de suppression pour revenir en arrière */
+            if (i > 0){ /* Pour éviter name[-1] */
+                i--;
+                space -= 8;
+                /* On dessine un rectangle noir sur les caractères pour les effacer */
+                MLV_draw_filled_rectangle(x + SIZE_CASE * 7 + space, y, 20, 20, MLV_COLOR_BLACK);
+            }
+        }
+        else if (i < size) { /* Pour éviter un index out of range */
+            text = MLV_convert_unicode_to_string(unicode); /* on récupère le caractère avec text.. */
+            MLV_draw_text(x + SIZE_CASE * 7 + space, y, text, MLV_COLOR_WHITE);
+            name[i] = text[0]; /* ..qu'on ajoute à 'name' */
+            free(text);
+            space += 8;
+            i++;
+        }
+    }
+}
+
+
+/* Initialisation de l'image 'image' et changement de sa taille pour l'adapter au jeu */
+int init_image(const char *image){
+    MLV_Image *img;
+    img = MLV_load_image(image);
+    if (img == NULL) return -1;
+    MLV_resize_image(img, WINDOW_WIDTH + SPACE, WINDOW_HEIGHT + SPACE);
+    MLV_draw_image(img, 0, 0);
+    return 0;
+}
+
+/* Permet d'afficher du texte avec fonte */
+int draw_text(int x, int y, char* text, int size, MLV_Color color){
+    MLV_Font *font;
+    font = MLV_load_font("img/MustardSmile.ttf", size);
+    if (font == NULL) return -1;
+    MLV_draw_text_with_font(x, y, text, font, color);
+    return 0;
+}
+
+/* Permet l'affichage du logo du jeu */
+int draw_logo(){
+    if (draw_text(WINDOW_WIDTH / 10 - 5, WINDOW_HEIGHT / 7,  "Stealth ", 68, MLV_COLOR_YELLOW2) == -1) return -1;
+    if (draw_text(WINDOW_WIDTH / 10 + 47, WINDOW_HEIGHT / 7 + 70 + 30 , " Game", 68, MLV_COLOR_YELLOW2) == -1) return -1;
+    if (draw_text(WINDOW_WIDTH / 10 - 5, WINDOW_HEIGHT / 7 ,"Stealth ", 65, MLV_COLOR_RED2) == -1) return -1;
+    if (draw_text(WINDOW_WIDTH / 10 + 47, WINDOW_HEIGHT / 7 + 70 + 30, " Game", 65, MLV_COLOR_RED2) == -1) return -1;
+    return 0;
+}
+
+/* Écrit les choix du menu dans un rectangle adapté */
+int draw_box(){
+    MLV_Font *font;
+    font = MLV_load_font("img/MustardSmile.ttf", 50);
+    if (font == NULL) return -1;
+    /* Choix pour Jouer */
+    MLV_draw_adapted_text_box_with_font(
+                X_BOX_PLAY , Y_BOX_PLAY,
+                " PLAY ",
+                font,
+                10,
+                MLV_COLOR_RED, MLV_COLOR_RED, MLV_COLOR_BLUE4,
+                MLV_TEXT_CENTER
+    );
+    /* Choix pour Quitter */
+    MLV_draw_adapted_text_box_with_font(
+                X_BOX_QUIT, Y_BOX_QUIT,
+                " QUIT ",
+                font,
+                10,
+                MLV_COLOR_YELLOW, MLV_COLOR_YELLOW, MLV_COLOR_BLUE4,
+                MLV_TEXT_CENTER
+    ); 
+    return 0;
+}
+
+/* Affiche l'intégralité du menu comprenant à l'arrière plan l'image de nom 'img_name' */
+int draw_menu(char *img_name){
+    if (init_image(img_name) == -1) return -1;
+    if (draw_logo() == -1) return -1;
+    if (draw_box() == -1) return -1;
+    MLV_actualise_window();
+    return 0;
+}
+
+
+/* Gestion de clic dans le menu. Renvoie 1 si le clic est sur Play, sinon 0 car sur Quit */
+int play(){
+    int x, y;
+    while(1){
+        MLV_get_mouse_position(&x, &y);
+        /* Clic pour Play */
+        if (MLV_get_mouse_button_state( MLV_BUTTON_LEFT ) == MLV_PRESSED ){
+            if (x > X_BOX_PLAY && x < X_BOX_PLAY + 160 && y > Y_BOX_PLAY && y < Y_BOX_PLAY + 75){
+                return 1;
+            }
+        }
+        /* Clic pour Quit */
+        if (MLV_get_mouse_button_state( MLV_BUTTON_LEFT ) == MLV_PRESSED ){
+            if (x > X_BOX_QUIT && x < X_BOX_QUIT + 160 && y > Y_BOX_QUIT && y < Y_BOX_QUIT + 75){
+                return 0;
+            }   
+        }
+        MLV_actualise_window();
+    }
+}
\ No newline at end of file
diff --git a/src/Grid.c b/src/Grid.c
new file mode 100644
index 0000000..50d5b75
--- /dev/null
+++ b/src/Grid.c
@@ -0,0 +1,73 @@
+#include "../include/Grid.h"
+#include <stdio.h>
+
+
+/* Initialise la grille 'grid' */
+void initialize_grid(Grid *grid){
+    int i, j;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            /* Création des 4 murs extérieurs */
+            if (i == 0 || i == NB_LIN - 1 || j == 0 || j == NB_COL - 1) grid->tab[i][j] = WALL;
+            /* Création de l'entrée */
+            else if (i >= 1 && i <= 2 && j >= 1 && j <= 2) grid->tab[i][j] = ENTRANCE;
+            else grid->tab[i][j] = EMPTY;
+        }
+    }
+}
+
+/* Affiche la grille 'grid' */
+void show_grid(const Grid *grid){
+    int i, j;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            switch(grid->tab[i][j]){
+                case WALL: printf("x"); break;
+                case RELIC: printf("r"); break;
+                case MANA: printf("-"); break;
+                default: printf(" ");
+            }
+        }
+        printf("\n");
+    }
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est vide, 0 sinon */
+int is_empty(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == EMPTY;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case d'entrée, 0 sinon */
+int is_entrance(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == ENTRANCE;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case d'ouverture, 0 sinon */
+int is_gap(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == GAP;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case de mur, 0 sinon */
+int is_wall(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == WALL;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case de relique, 0 sinon */
+int is_relic(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == RELIC;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case de mana, 0 sinon */
+int is_mana(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == MANA;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case indiquant une relique prise, 0 sinon */
+int is_relic_taken(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == RELIC_TAKEN;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case indiquant une relique détectée, 0 sinon */
+int is_relic_detect(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == RELIC_DETECT;
+}
\ No newline at end of file
diff --git a/src/Guard.c b/src/Guard.c
new file mode 100644
index 0000000..2250abc
--- /dev/null
+++ b/src/Guard.c
@@ -0,0 +1,47 @@
+#include "../include/Guard.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+
+/* Initialise le gardien 'guard' */
+void initialize_guard(Guard *guard){
+    Point center = {0.0, 0.0};
+    guard->disc.center = center;
+    guard->disc.radius = SIZE_CASE / 2;
+    enter_normal_mode(&(*guard));
+    change_direction_speed_guard(&(*guard));
+}
+
+/* Fait entrer le gardien 'guard' en mode normal */
+void enter_normal_mode(Guard *guard){
+    guard->mode = NORMAL;
+    guard->detection_dist = DETECT_DIST_NL;
+}
+
+/* Fait entrer le gardien 'guard' en mode panique */
+void enter_panic_mode(Guard *guard){
+    guard->mode = PANIC;
+    guard->speed = SPEED_PC;
+    guard->detection_dist = DETECT_DIST_PC;
+}
+
+/* Renvoie une vitesse aléatoire entre 'min' et 'max' */
+double random_speed(double min, double max){
+    return rand() / (double) RAND_MAX * (max - min) + min;
+}
+
+/* Renvoie aléatoirement l'une des 4 directions UP, DOWN, LEFT et RIGHT */
+Direction random_direction(){
+    return rand() % 4;
+}
+
+/* Change aléatoirement la direction et la vitesse du gardien 'guard' */
+void change_direction_speed_guard(Guard *guard){
+    guard->dir = random_direction();
+    if (guard->mode == NORMAL) guard->speed = random_speed(MIN_SPEED_NL, MAX_SPEED_NL);
+}
+
+/* Change la position du gardien 'guard' */
+void change_position_guard(Guard *guard){
+    change_position(&guard->disc, guard->dir, guard->speed);
+}
diff --git a/src/Main.c b/src/Main.c
new file mode 100644
index 0000000..0e82a88
--- /dev/null
+++ b/src/Main.c
@@ -0,0 +1,122 @@
+#define _POSIX_C_SOURCE 199309L
+#include "../include/GameEngine.h"
+#include "../include/Graphic.h"
+#include "../include/Ranking.h"
+#include <MLV/MLV_all.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+
+int main(){
+    srand(time(NULL));
+    MLV_Music* music;
+    int quit, win;
+    struct timespec start, end;
+    Room room;
+    Rankings rankings;
+    Score score;
+
+    /* Initialisation de variables */
+    initialize_room(&room);
+    initialize_rankings(&rankings);
+    initialize_score(&score);
+    quit = 0;
+
+    /* Fenêtre du jeu */
+    MLV_create_window("Game", "Game", WINDOW_WIDTH, WINDOW_HEIGHT + SPACE);
+
+    /* Initialisation d'une musique de fond */
+    MLV_init_audio();
+    music = MLV_load_music("sound/sound.ogg");
+    if (music == NULL) {
+        fprintf(stderr, "Error while loading sound\n");
+        exit(EXIT_FAILURE);
+    }
+    MLV_play_music(music, 1.0, -1);
+
+    /* Menu */
+    if (draw_menu("img/menu.jpg") == -1){
+        fprintf(stderr, "Error while drawing menu\n");
+        exit(EXIT_FAILURE);
+    }
+    if (!play()) exit(EXIT_SUCCESS);
+
+
+    MLV_clear_window(MLV_COLOR_BLACK);
+    clock_gettime(CLOCK_REALTIME, &start);
+    /* Boucle maîtresse gérant le jeu frame par frame 
+     (le programme doit faire NB_FRAMES_PER_S frames par seconde) */
+    while(!quit){
+        struct timespec end_time, new_time;
+        double frametime, extratime;
+        /* On récupère le temps en nanoseconde au début de la frame */
+        clock_gettime(CLOCK_REALTIME, &end_time);
+
+        /* Affichage de la frame courante */
+        draw_room(&room);
+
+        /* Gère les mécanismes du jeu */
+        move_guards_in_room(&room);
+        move_player_in_room(&room);
+        absorb_manas_in_room(&room);
+        use_player_competences_in_room(&room, &score.mana_used);
+        take_relics_in_room(&room);
+        manage_guards_modes_in_room(&room);
+
+        /* Conditions de fin de partie */
+        if (player_detected_in_room(&room)){
+            win = 0;
+            quit = 1;
+        }
+        if (player_mission_accomplished(&room)){
+            win = 1;
+            quit = 1;
+        }
+
+        /* On récupère le temps en nanoseconde à la fin de la frame */
+        clock_gettime(CLOCK_REALTIME, &new_time);
+
+        /* Calcule du temps passé entre le début et la fin de la frame */
+        frametime = new_time.tv_sec - end_time.tv_sec;
+        frametime += (new_time.tv_sec - end_time.tv_sec) / 1.0E9;
+
+        /* On force le programme à passer au moins 1/NB_FRAMES_PER_S seconde au total */
+        extratime = 1.0 / NB_FRAMES_PER_S - frametime;
+        if (extratime > 0){
+            MLV_wait_milliseconds((int) (extratime * 1000));
+        }
+    }
+    MLV_wait_seconds(1);
+    MLV_clear_window(MLV_COLOR_BLACK);
+
+    clock_gettime(CLOCK_REALTIME, &end);
+    /* Calcule du temps réalisé par le joueur */
+    score.time = time_achieved(&start, &end);
+
+    /* Affichage du résultat de la partie, du temps réalisé et de la quantité de mana dépensée */
+    draw_end_game(win, &score);
+
+    /* Si le joueur gagne, il peut entrer son nom dans le tableau des meilleurs scores */
+    if (win){
+        draw_enter_name(score.name, SIZE_NAME);
+        if (save_score("rankings.bin", &score) == -1){
+            fprintf(stderr, "Error while saving score\n");
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    /* Affichage du tableau de classement */
+    if (get_scores("rankings.bin", &rankings) == -1){
+        fprintf(stderr, "Error while getting scores\n");
+        exit(EXIT_FAILURE);
+    }
+    draw_rankings(&rankings);
+
+    MLV_wait_seconds(10);
+    MLV_stop_music();
+    MLV_free_music(music);
+    MLV_free_audio();
+    MLV_free_window();
+    return 0;
+}
\ No newline at end of file
diff --git a/src/Player.c b/src/Player.c
new file mode 100644
index 0000000..8a0b931
--- /dev/null
+++ b/src/Player.c
@@ -0,0 +1,91 @@
+#include "../include/Player.h"
+#include <stdio.h>
+
+
+/* Initialise le joueur 'player' */
+void initialize_player(Player *player){
+    Point center = {0.0, 0.0};
+    player->disc.center = center;
+    player->disc.radius = SIZE_CASE / 2;
+    player->dir = RIGHT;
+    player->speed = INITIAL_SPEED;
+    player->max_speed = MAX_SPEED;
+    player->mana = 0;
+    player->max_mana = MAX_MANA;
+    player->comp.acceleration = UNUSED;
+    player->comp.invisibility = UNUSED;
+}
+
+/* Change la position de l'agent 'agent' suivant sa direction 'dir' et sa vitesse 'speed' */
+void change_position(Disc *agent, Direction dir, double speed){
+    double offset_x[] = {0, 0, -speed, speed};
+    double offset_y[] = {-speed, speed, 0, 0};
+    agent->center.x += offset_x[dir];
+    agent->center.y += offset_y[dir];    
+}
+
+/* Change la position du joueur 'player' */
+void change_position_player(Player *player){
+    change_position(&player->disc, player->dir, player->speed);
+}
+
+/* Renvoie 1 si les directions 'd1' et 'd2' sont les mêmes, 0 sinon.
+ * Les directions latérales sont uniquement comparées entre elles et pour les directions horizontales également
+ * (donc Haut est seulement comparée à Bas et vice versa et Gauche seulement à Droite et vice versa)
+*/
+int same_direction(Direction d1, Direction d2){
+    if ((d1 == UP && d2 == DOWN) || (d1 == DOWN && d2 == UP)) return 0;
+    if ((d1 == LEFT && d2 == RIGHT) || (d1 == RIGHT && d2 == LEFT)) return 0;
+    return 1;
+}
+
+/* Change la direction et la vitesse du joueur 'player' suivant la direction choisie 'pressed' */
+void change_direction_speed_player(Player *player, Direction pressed){
+    if (same_direction(pressed, player->dir)){
+        player->speed += ACC;
+        if (player->speed > player->max_speed) player->speed = player->max_speed;
+    }
+    /* Quand on change de direction, la vitesse est réinitialisée */
+    else player->speed = INITIAL_SPEED;
+    player->dir = pressed;
+}
+
+/* Active la compétence Accélération du joueur 'player' */
+void activate_acceleration(Player *player){
+    if (player->mana >= ACC_MANA && player->comp.acceleration == UNUSED){
+        player->comp.acceleration = USED;
+        player->max_speed = MAX_SPEED_ACC;
+    }    
+}
+
+/* Désactive la compétence Accélération du joueur 'player' */
+void desactivate_acceleration(Player *player){
+    player->comp.acceleration = UNUSED;
+    player->max_speed = MAX_SPEED;
+}
+
+/* Fait utiliser la compétence Accélération du joueur 'player' donc du mana est consommé */
+void use_acceleration(Player *player){
+    if (player->comp.acceleration == USED && player->mana >= ACC_MANA) player->mana -= ACC_MANA;
+    if (player->mana < ACC_MANA) desactivate_acceleration(&(*player));
+}
+
+/* Active la compétence Invisibilité du joueur 'player' */
+void activate_invisibility(Player *player){
+    if (player->mana >= INV_MANA && player->comp.invisibility == UNUSED){
+        player->comp.invisibility = USED;
+    }
+}
+
+/* Désactive la compétence Invisibilité du joueur 'player' */
+void desactivate_invisibility(Player *player){
+    player->comp.invisibility = UNUSED;
+}
+
+/* Fait utiliser la compétence Invisibilité du joueur 'player' donc du mana est consommé */
+void use_invisibility(Player *player){
+    if (player->comp.invisibility == USED && player->mana >= INV_MANA){
+        player->mana -= INV_MANA;
+    }
+    if (player->mana < INV_MANA) desactivate_invisibility(&(*player));
+}
diff --git a/src/Point.c b/src/Point.c
new file mode 100644
index 0000000..fc01d21
--- /dev/null
+++ b/src/Point.c
@@ -0,0 +1,38 @@
+#include "../include/Point.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+
+/* Calcule la distance euclidienne entre les points 'a' et 'b' */
+double distance(Point a, Point b){
+    double dx, dy;
+    dx = b.x - a.x;
+    dy = b.y - a.y;
+    return sqrt(pow(dx, 2) + pow(dy, 2));
+}
+
+/* Renvoie un entier aléatoire entre les entiers 'a' et 'b' (tous deux compris) */
+int random_int(int a, int b){
+    return rand() % (b - a + 1) + a;
+}
+
+/* Renvoie un double aléatoire entre les entiers 'a' et 'b' (tous deux compris) */
+double random_double(int a, int b){
+    int n, nb_decimal;
+    nb_decimal = 1;
+    n = pow(10, nb_decimal);
+    a *= n;
+    b *= n;
+    return (random_int(a, b)) / (double) n;
+}
+
+/* Renvoie un point aléatoire.
+ * La coordonnée x (resp. y) du point est entre 'x1' et 'x2' (resp. 'y1' et 'y2').
+*/
+Point random_point(int x1, int x2, int y1, int y2){
+    Point point;
+    point.x = random_double(x1, x2);
+    point.y = random_double(y1, y2);
+    return point;
+}
\ No newline at end of file
diff --git a/src/Ranking.c b/src/Ranking.c
new file mode 100644
index 0000000..0b07b89
--- /dev/null
+++ b/src/Ranking.c
@@ -0,0 +1,107 @@
+#include "../include/Ranking.h"
+
+
+/* Initialise le score 'score' */
+void initialize_score(Score *score){
+    score->time = 0.0;
+    score->mana_used = 0;
+}
+
+/* Initialise les classements dans 'r' */
+void initialize_rankings(Rankings *r){
+    int i;
+    Score score;
+    initialize_score(&score);
+    for (i = 0; i < MAX_S; i++){
+        r->best_times[i] = score;
+        r->best_mana_used[i] = score;
+    }
+    r->nb_t = 0;
+    r->nb_m = 0;
+}
+
+
+/* Renvoie le temps passé en seconde entre 'start' et 'end' */
+double time_achieved(struct timespec *start, struct timespec *end){
+    return (end->tv_sec - start->tv_sec) + ((end->tv_nsec - start->tv_nsec) / 1.0E9);
+}
+
+
+/* Décale tous les éléments Score de 'tab' de taille 'size' à droite à partir de l'indice 'index' */
+void shift_right(Score *tab, int size, int index){
+    int i;
+    for (i = size - 1; i > index; i--){
+       tab[i] = tab[i - 1];
+    }
+}
+
+/* Met à jour dans 'r' le classement par meilleur temps en y ajoutant possiblement le nouveau score 'score'.
+ "possiblement" car si 'score' n'a pas un meilleur temps que les MAX_S scores déjà inscrits, il ne sera pas ajouté
+*/
+void update_best_times(Rankings *r, const Score *score){
+    int i;
+    for (i = 0; i < MAX_S; i++){
+        if (r->nb_t == i){
+            r->best_times[i] = *score;
+            r->nb_t++;
+            return;
+        }
+        else if (score->time < r->best_times[i].time){
+            shift_right(r->best_times, MAX_S, i);
+            r->best_times[i] = *score;
+            return;
+        }
+    }
+}
+
+/* Met à jour dans 'r' le classement par meilleure consommation de mana en y ajoutant possiblement le nouveau score 'score'.
+ "possiblement" car si 'score' n'a pas une meilleure consommation de mana que les MAX_S scores déjà inscrits, il ne sera pas ajouté
+*/
+void update_best_mana_used(Rankings *r, const Score *score){
+    int i;
+    for (i = 0; i < MAX_S; i++){
+        if (r->nb_m == i){
+            r->best_mana_used[i] = *score;
+            r->nb_m++;
+            return;
+        }
+        else if (score->mana_used < r->best_mana_used[i].mana_used){
+            shift_right(r->best_mana_used, MAX_S, i);
+            r->best_mana_used[i] = *score;
+            return;
+        }
+    }
+}
+
+/* Met à jour les classements dans 'r' en y ajoutant possiblement le nouveau score 'score' */
+void update_rankings(Rankings *r, const Score *score){
+    update_best_times(&(*r), score);
+    update_best_mana_used(&(*r), score);
+}
+
+
+/* Permet de sauvegarder dans le fichier nommé 'name' le score 'score' */
+int save_score(char *name, const Score *score){
+    FILE *file;
+    file = fopen(name, "ab");
+    if (file == NULL) return -1;
+    if (fwrite(&(*score), sizeof(Score), 1, file) != 1) return -1; /* Erreur lors de l'écriture */
+    fclose(file);
+    return 0;
+}
+
+/* Permet de récupérer les éléments Score dans le fichier nommé 'name' pour remplir les classements dans 'r' */
+int get_scores(char *name, Rankings *r){
+    int n;
+    Score score;
+    FILE *file;
+    file = fopen(name, "rb");
+    if (file == NULL) return -1;
+
+    /* tant qu'on a pas lu tous les Score de 'file' */
+    while ((n = fread(&score, sizeof(Score), 1, file)) == 1){
+        update_rankings(&(*r), &score);
+    }
+    fclose(file);
+    return 0;
+}
diff --git a/src/Terrain.c b/src/Terrain.c
new file mode 100644
index 0000000..8468d88
--- /dev/null
+++ b/src/Terrain.c
@@ -0,0 +1,267 @@
+#include "../include/Terrain.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+
+/* Génère un mur vertical dans la grille 'grid' de la ligne 'start_y' à la ligne 'end_y' à la colonne n°'column' */
+void generate_vertical_wall(Grid *grid, int column, int start_y, int end_y){
+    int i, alea;
+
+    alea = rand() % 2; /* Pour savoir à quelle extrémité du mur les cases d'ouvertures doivent être placées */
+    for (i = start_y; i <= end_y; i++){
+        grid->tab[i][column] = WALL;
+        if (alea == 0 && i < start_y + LENGTH_GAP) grid->tab[i][column] = GAP;
+        if (alea == 1 && i > end_y - LENGTH_GAP) grid->tab[i][column] = GAP;
+    }
+}
+
+/* Génère un mur horizontal dans la grille 'grid' de la colonne 'start_x' à la colonne 'end_x' à la ligne n°'line' */
+void generate_horizontal_wall(Grid *grid, int line, int start_x, int end_x){
+    int i, alea;
+
+    alea = rand() % 2; /* Pour savoir à quelle extrémité du mur les cases d'ouvertures doivent être placées */
+    for (i = start_x; i <= end_x; i++){
+        grid->tab[line][i] = WALL;
+        if (alea == 0 && i < start_x + LENGTH_GAP) grid->tab[line][i] = GAP;
+        if (alea == 1 && i > end_x - LENGTH_GAP) grid->tab[line][i] = GAP;
+    }
+}
+
+/* Cherche aléatoirement un numéro de ligne ou colonne entre 'start' et 'end' pour savoir où placer un mur de façon 
+ * à ce que la taille (en longueur ou largeur) des deux compartiments crées à gauche et à droite soit plus grande que MINSIDE.
+ * On récupère via 'pos' la position de la ligne ou colonne où le mur sera généré.
+ * On récupère également au passage avec 'left' et 'right' la taille des compartiments gauche et droite crées
+*/
+void random_position_for_wall(int *pos, int start, int end, int *left, int *right){
+    while (*left < MINSIDE || *right < MINSIDE){
+        *pos = random_int(start, end);
+        *left = *pos - start;
+        *right = end - *pos;
+    }
+}
+
+/* Subdivise la grille 'grid' en plusieurs compartiments dans l'espace libre de taille 'x' x 'y'.
+ * La longueur 'x' débute à la colonne 'start_x' et finit à la colonne 'end_x'.
+ * De même, la largeur 'y' débute à la ligne 'start_y' et finit à la ligne 'end_y'
+*/
+void generate_compartments(Grid *grid, int x, int start_x, int end_x, int y, int start_y, int end_y){
+    int pos;
+    int length_left = -1, length_right = -1;
+
+    if (x > y){
+        if (x < 2 * MINSIDE + 1) return;
+        else if (x < 4 * MINSIDE){
+            if (rand() % 2 == 0) return;   
+        }
+        random_position_for_wall(&pos, start_x, end_x, &length_left, &length_right);
+        generate_vertical_wall(&(*grid), pos, start_y, end_y);
+        /* On relance l'algo récursivement sur les deux compartiments générés */
+        generate_compartments(&(*grid), length_left, start_x, pos - 1, y, start_y, end_y);
+        generate_compartments(&(*grid), length_right, pos + 1, end_x, y, start_y, end_y);
+    }
+    else if (y > x){
+        if (y < 2 * MINSIDE + 1) return;
+        else if (y < 4 * MINSIDE){
+            if (rand() % 2 == 0) return;   
+        }
+        random_position_for_wall(&pos, start_y, end_y, &length_left, &length_right);
+        generate_horizontal_wall(&(*grid), pos, start_x, end_x);
+        /* On relance l'algo récursivement sur les deux compartiments générés */
+        generate_compartments(&(*grid), x, start_x, end_x, length_left, start_y, pos - 1);
+        generate_compartments(&(*grid), x, start_x, end_x, length_right, pos + 1, end_y);
+    }
+}
+
+
+/* Place le joueur 'player' dans la grille */
+void place_player_in_grid(Player *player){
+    player->disc.center.x = INITIAL_POS_X;
+    player->disc.center.y = INITIAL_POS_Y;
+}
+
+
+/* Renvoie 1 si le point 'point' est à une distance d'au moins MINDIST de la position du joueur 'player', 0 sinon */
+int far_enough_from_the_player(Point point, const Player *player){
+    return distance(point, player->disc.center) >= MINDIST;
+}
+
+/* Renvoie la case contenant le point 'point' */
+Case point_case(Point point){
+    Case c;
+    c.lin = floor(point.y / SIZE_CASE);
+    c.col = floor(point.x / SIZE_CASE);
+    return c;
+}
+
+/* Redimensionne les coordonnées du point 'point' pour l'adapter aux dimensions "réelles" du terrain */
+void resize_point(Point *point){
+    point->x *= SIZE_CASE;
+    point->y *= SIZE_CASE;
+}
+
+
+/* Place 'nb_relics' reliques dans la grille 'grid' assez loin du joueur 'player' */
+void place_relics_in_grid(int nb_relics, Grid *grid, const Player *player){
+    int i, valid;
+    Case coord;
+    Point point;
+
+    for (i = 0; i < nb_relics; i++){
+        valid = 0;
+        while (!valid){
+            point = random_point(1, NB_COL - 2, 1, NB_LIN - 2);
+            resize_point(&point);
+            if (far_enough_from_the_player(point, &(*player))){
+                coord = point_case(point);
+                if (is_empty(&(*grid), coord)){
+                    grid->tab[coord.lin][coord.col] = RELIC;
+                    valid = 1;
+                }
+            }
+        }
+    }
+}
+
+/* Place les cases de mana dans la grille 'grid' */
+void place_manas_in_grid(Grid *grid){
+    int i, j;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            Case coord = {i, j};
+            if (is_empty(&(*grid), coord) || is_gap(&(*grid), coord)) grid->tab[i][j] = MANA;
+        }
+    }
+}
+
+/* Place une tuile de mana aléatoirement dans la grille 'grid' */
+void place_random_mana_in_grid(Grid *grid){
+    int valid;
+    Point point;
+    Case coord;
+
+    valid = 0;
+    while (!valid){
+        point = random_point(1, NB_COL - 2, 1, NB_LIN - 2);
+        resize_point(&point);
+        coord = point_case(point);
+        if (is_empty(&(*grid), coord)){
+            grid->tab[coord.lin][coord.col] = MANA;
+            valid = 1;
+        }
+    }
+}
+
+
+/* Renvoie 1 si le gardien 'guard' touche ou se superpose à un autre gardien de 'tab' de taille 'size'.
+ * 'index' est l'indice du gardien 'guard' dans le tableau 'tab'.
+*/
+int superposition_between_guards(const Guard *guard, int index, const Guard *tab, int size){
+    int i;
+    for (i = 0; i < size; i++){
+        /* On ne compare pas le gardien 'guard' à lui-même */
+        if (i != index){
+            if (superposition_between_discs(guard->disc, tab[i].disc)) return 1;
+        }
+    }
+    return 0;
+}
+
+/* Renvoie 1 si le gardien 'guard' rentre dans un mur 
+ * possiblement situé sur l'une des 4 cases diagonales adjacentes à la sienne, 0 sinon 
+*/
+int in_diagonal_wall(const Guard *guard, const Grid *grid){
+    int i, j;
+    Case c_guard; /* Case contenant le centre du disque du gardien */
+    c_guard = point_case(guard->disc.center);
+
+    for (i = -1; i < 2; i++){
+        for (j = -1; j < 2; j++){
+            if (i != 0 && j != 0){
+                /* On ne veut que les cases situées sur les diagonales */
+                Case diagonal = {c_guard.lin + i, c_guard.col + j};
+
+                if (is_wall(&(*grid), diagonal)){
+                    /* On veut le coin de case qui est commun à la case 'c_guard' et 'diagonal' */
+                    if (i == -1) diagonal.lin += 1;
+                    if (j == -1) diagonal.col += 1;
+                    Point corner = {diagonal.col, diagonal.lin};
+                    resize_point(&corner);
+                    /* Si ce coin est à l'intérieur du disque du gardien, alors 
+                    cela veut dire que le gardien rentre dans la case 'diagonal' */
+                    if (point_inside_disc(corner, guard->disc)) return 1;
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+/* Renvoie 1 si le gardien 'guard' rentre dans un mur ou une ouverture
+ * possiblement situé sur l'une des 4 cases latérales adjacentes à la sienne, 0 sinon 
+*/
+int in_lateral_wall_or_gap(const Guard *guard, const Grid *grid){
+    int i, j;
+    Case c_guard; /* Case contenant le centre du disque du gardien */
+    Point middle; /* Point du milieu commun à la case 'c_guard' 
+                   et la case ('up_down' ou 'left_right') dont on cherche à savoir si c'est un mur ou une ouverture */
+    c_guard = point_case(guard->disc.center);
+    
+    /* Case en haut et en bas */
+    for (i = -1; i < 2; i++){
+        Case up_down = {c_guard.lin + i, c_guard.col};
+        if (i != 0 && (is_wall(&(*grid), up_down) || is_gap(&(*grid), up_down))){
+            middle.x = up_down.col + (1 / (double) 2);
+
+            if (i == -1) middle.y = up_down.lin + 1;
+            else if (i == 1) middle.y = up_down.lin;
+
+            resize_point(&middle);
+            if (point_inside_disc(middle, guard->disc)) return 1;
+        }
+    }
+    /* Case à gauche et à droite */
+    for (j = -1; j < 2; j++){
+        Case left_right = {c_guard.lin, c_guard.col + j};
+        if (j != 0 && (is_wall(&(*grid), left_right) || is_gap(&(*grid), left_right))){
+            middle.y = left_right.lin + (1 / (double) 2);
+
+            if (j == -1) middle.x = left_right.col + 1;
+            else if (j == 1) middle.x = left_right.col;
+
+            resize_point(&middle);
+            if (point_inside_disc(middle, guard->disc)) return 1;
+        }
+    }
+    return 0;
+}
+
+/* Place le gardien 'guard' dans la grille 'grid' assez loin du joueur 'player'
+ * et en prenant en compte les autres gardiens dans 'tab' de taille 'size'.
+ * 'index' est l'indice du gardien 'guard' dans le tableau 'tab'.
+*/
+void place_guard_in_grid(Guard *guard, int index, const Guard *tab, int size, const Grid *grid, const Player *player){
+    int valid;
+    Case coord;
+    Point point;
+    
+    valid = 0;
+    while (!valid){
+        point = random_point(1, NB_COL - 2, 1, NB_LIN - 2);
+        resize_point(&point);
+        if (far_enough_from_the_player(point, &(*player))){
+
+            coord = point_case(point);
+            if (!is_wall(&(*grid), coord) && !is_gap(&(*grid), coord)){
+
+                guard->disc.center.x = point.x;
+                guard->disc.center.y = point.y;
+                if (!superposition_between_guards(&(*guard), index, tab, size)){
+                    if (!in_diagonal_wall(&(*guard), &(*grid))){
+                        if (!in_lateral_wall_or_gap(&(*guard), &(*grid))) valid = 1;
+                    }
+                }
+            }
+        }
+    }
+}
\ No newline at end of file

commit 126d763f81627f944b11827eae385c38eb1a239a
Author: lina GUERROUI <padawan@DebianUPEM2019.padawan>
Date:   Fri Jan 13 05:17:04 2023 +0100

    creation du menu avec deux bouttons + musique du fond

diff --git a/Menu.c b/Menu.c
new file mode 100644
index 0000000..4d5796e
--- /dev/null
+++ b/Menu.c
@@ -0,0 +1,102 @@
+#include "Menu.h"
+
+
+/*initialisation de image et chngement de sa taille*/
+void init_image( const char *image){
+    MLV_Image *img;
+    img = MLV_load_image(image);
+    MLV_resize_image ( img, WINDOW_WIDTH, WINDOW_HEIGHT );
+    MLV_draw_image(img, 0, 0);
+}
+
+/* fonction pour afficher text*/
+void draw_text (int x, int y, char* text, int size, MLV_Color color){
+    MLV_Font* font ;
+    font  = MLV_load_font( "MustardSmile.ttf" , size);
+    MLV_draw_text_with_font(x ,y , text, font,color); 
+}
+
+/*affichage du logo du jeu */
+void draw_logo(){
+    draw_text (WINDOW_WIDTH / 10  -5, WINDOW_HEIGHT / 7,  "Stealth ", 68, MLV_COLOR_YELLOW2);
+    draw_text (((WINDOW_WIDTH / 10) + 47), WINDOW_HEIGHT / 7 + 70 + 30 , " Game", 68, MLV_COLOR_YELLOW2);
+    draw_text (WINDOW_WIDTH / 10 - 5, WINDOW_HEIGHT / 7 ,"Stealth ", 65, MLV_COLOR_RED2);
+    draw_text (WINDOW_WIDTH / 10 + 47, WINDOW_HEIGHT / 7 + 70 + 30, " Game", 65, MLV_COLOR_RED2);
+}
+
+/*texte dans un rectangle adapté */
+void draw_box(){
+    MLV_Font* font ;
+    font  = MLV_load_font( "MustardSmile.ttf" , 50);
+    MLV_draw_adapted_text_box_with_font(
+                X_BOX_PLAY , Y_BOX_PLAY,
+                " PLAY ",
+                font,
+                10,
+                MLV_COLOR_RED, MLV_COLOR_RED, MLV_COLOR_BLUE4,
+                MLV_TEXT_CENTER
+        );  
+    
+    MLV_draw_adapted_text_box_with_font(
+                X_BOX_EXIT, Y_BOX_EXIT,
+                "EXIT",
+                font,
+                10,
+                MLV_COLOR_YELLOW, MLV_COLOR_YELLOW, MLV_COLOR_BLUE4,
+                MLV_TEXT_CENTER
+        ); 
+}
+
+/*afficher tout le menu */
+void disp_menu(){
+    init_image("img.jpg");
+    draw_logo();
+    draw_box();        
+    MLV_actualise_window();
+}
+
+/*gestion de clique dans le menu
+    renvoie 1 si le clique est dur Play 
+    renvoie 0 si le clique sur Exit*/
+int play (){
+    int x,y;
+    while( 1 ){
+        MLV_get_mouse_position( &x, &y );
+        /* si on clique sur play return 1*/
+        if( MLV_get_mouse_button_state( MLV_BUTTON_LEFT ) == MLV_PRESSED ){
+            MLV_get_mouse_position( &x, &y );
+            if(x > X_BOX_PLAY && x < X_BOX_PLAY + 160 && y > Y_BOX_PLAY && y < Y_BOX_PLAY + 75 ){
+                return 1;
+            }
+        /*si on clique sur Exit return 0*/
+        else if( MLV_get_mouse_button_state( MLV_BUTTON_LEFT ) == MLV_PRESSED ){
+            if(x > X_BOX_EXIT && x < X_BOX_EXIT + 140 && y > Y_BOX_EXIT && y < Y_BOX_EXIT + 75 ){
+                return 0;
+            }   
+        }
+        MLV_actualise_window();
+        }
+    }
+}
+
+
+
+
+/* a inserer dans le main*/
+void music(){
+
+    /*initialisation musique*/
+    MLV_init_audio( );
+    MLV_Music* music = MLV_load_music( "sound.ogg" );
+    MLV_play_music( music, 1.0, -1 );
+
+
+    MLV_wait_seconds( 30 ); /* déroulement du jeu*/
+
+
+    /*arret de la musique ( avec un if fin de la partie)*/
+    MLV_stop_music();
+    MLV_free_music( music );
+    MLV_free_audio();
+
+}
diff --git a/Menu.h b/Menu.h
new file mode 100644
index 0000000..fdfec5a
--- /dev/null
+++ b/Menu.h
@@ -0,0 +1,22 @@
+#ifndef __MENU__
+#define __MENU__
+
+
+#include <MLV/MLV_all.h>
+#include "Graphic.h"
+
+
+#define X_BOX_PLAY WINDOW_WIDTH /12
+#define Y_BOX_PLAY WINDOW_HEIGHT - (WINDOW_HEIGHT / 6)
+#define X_BOX_EXIT WINDOW_WIDTH - (WINDOW_WIDTH /6 )
+#define Y_BOX_EXIT WINDOW_HEIGHT - (WINDOW_HEIGHT /6 )
+
+void init_image( const char *image);
+void draw_text (int x, int y, char* text, int size, MLV_Color color);
+void draw_logo();
+void draw_box();
+void disp_menu();
+int play ();
+void music();
+
+#endif
\ No newline at end of file
diff --git a/MustardSmile.ttf b/MustardSmile.ttf
new file mode 100644
index 0000000..e898e6c
Binary files /dev/null and b/MustardSmile.ttf differ
diff --git a/img.jpg b/img.jpg
new file mode 100644
index 0000000..0721f81
Binary files /dev/null and b/img.jpg differ
diff --git a/sound.ogg b/sound.ogg
new file mode 100644
index 0000000..b61e27f
Binary files /dev/null and b/sound.ogg differ

commit 4b38d6d854d7aa237d1cf163f28c57747fc1d7d2
Author: Sylvain Tran <sylvain.tran@etud.u-pem.fr>
Date:   Thu Jan 12 02:24:16 2023 +0100

    Absorption du mana dans la salle + placement aléatoire du mana dépensé; Récupération des reliques dans la salle; Gestion des modes des gardiens dans la salle

diff --git a/Collision.c b/Collision.c
index 7885cc0..825df9d 100644
--- a/Collision.c
+++ b/Collision.c
@@ -41,8 +41,7 @@ void determine_front_cases(Disc agent, Direction dir, int dist, Case *front, Cas
 int risk_collide_wall(Disc agent, Direction dir, int dist, const Grid *grid){
     Case f, f_s1, f_s2;
     determine_front_cases(agent, dir, dist, &f, &f_s1, &f_s2);
-    if (is_wall(&(*grid), f) || is_wall(&(*grid), f_s1) || is_wall(&(*grid), f_s2)) return 1;
-    return 0;
+    return is_wall(&(*grid), f) || is_wall(&(*grid), f_s1) || is_wall(&(*grid), f_s2);
 }
 
 
diff --git a/GameEngine.c b/GameEngine.c
index 977d7d8..7a9df99 100644
--- a/GameEngine.c
+++ b/GameEngine.c
@@ -15,15 +15,17 @@ void initialize_room(Room *room){
     initialize_player(&room->player);
     place_player_in_grid(&room->player);
 
-    /* Reliques + Manas */
+    /* Reliques */
     place_relics_in_grid(NB_RELICS, &room->grid, &room->player);
-    place_manas_in_grid(&room->grid);
 
     /* Gardiens */
     for (i = 0; i < NB_GUARDS; i++){
         initialize_guard(&room->guards[i]);
         place_guard_in_grid(&room->guards[i], i, room->guards, NB_GUARDS, &room->grid, &room->player);
     }
+
+    /* Manas */
+    place_manas_in_grid(&room->grid);
 }
 
 
@@ -43,11 +45,13 @@ void move_guard(Guard *guard, int index, const Guard *tab, int size, const Grid
 
     /* On veut qu'un gardien en mode panique change de direction si un mur est à une case de distance
      (donc pas directement devant lui mais 1 case plus loin) */
-    if (guard->mode == PANIC && !risk_collide_wall(guard->disc, guard->dir, 0, &(*grid))) dist = 1;
+    if (guard->mode == PANIC && !risk_collide_wall(guard->disc, guard->dir, 0, &(*grid))){
+        dist = 1;
+    }
 
     if (travel_limit(guard->disc, guard->dir, dist, &(*grid), &limit)){
         /* Si une limite de déplacement a été calculée, 
-         on regarde si le gardien ne dépasse pas cette limite */
+         on fait en sorte que le gardien ne dépasse pas cette limite */
         change_position_guard(&(*guard));
         if (collide_wall(&guard->disc, guard->dir, limit)){
             change_direction_speed_guard(&(*guard));
@@ -91,30 +95,52 @@ static int key_pressed(MLV_Keyboard_button key){
 void move_player_in_room(Room *room){
     int zqsd;
     zqsd = 0;
-    if (key_pressed(SDLK_z)){
+    if (key_pressed(SDLK_z)){ /* Touche z */
         move_player(&room->player, &room->grid, UP);
         zqsd = 1;
     }
-    if (key_pressed(SDLK_q)){
+    if (key_pressed(SDLK_q)){ /* Touche q */
         move_player(&room->player, &room->grid, LEFT);
         zqsd = 1;
     }
-    if (key_pressed(SDLK_s)){
+    if (key_pressed(SDLK_s)){ /* Touche s */
         move_player(&room->player, &room->grid, DOWN);
         zqsd = 1;
     }
-    if (key_pressed(SDLK_d)){
+    if (key_pressed(SDLK_d)){ /* Touche d */
         move_player(&room->player, &room->grid, RIGHT);
         zqsd = 1;
     }
     if (!zqsd) room->player.speed = INITIAL_SPEED;
 }
 
+
+/* Permet au joueur 'player' d'absorber une trace de mana dans la grille 'grid' */
+void absorb_mana(Player *player, Grid *grid){
+    Case coord;
+    coord = point_case(player->disc.center);
+    if (player->disc.center.x != INITIAL_POS_X || player->disc.center.y != INITIAL_POS_Y){
+        if (is_mana(&(*grid), coord) && player->mana < player->max_mana){
+            grid->tab[coord.lin][coord.col] = EMPTY;
+            player->mana += 1;
+        }
+    }
+}
+
+/* Permet d'absorber les traces de mana dans la salle 'room' */
+void absorb_manas_in_room(Room *room){
+    absorb_mana(&room->player, &room->grid);
+}
+
+
 /* Permet d'utiliser les compétences du joueur dans la salle 'room' */
 void use_player_competences_in_room(Room *room){
     int acc, inv;
+    int i, prev_mana, consume;
     acc = 0;
     inv = 0;
+    prev_mana = room->player.mana; /* Ancienne quantité de mana */
+
     if (key_pressed(SDLK_LSHIFT)){ /* Touche shift gauche */
         activate_acceleration(&room->player);
         use_acceleration(&room->player);
@@ -127,16 +153,79 @@ void use_player_competences_in_room(Room *room){
     }
     if (!acc) desactivate_acceleration(&room->player);
     if (!inv) desactivate_invisibility(&room->player);
+
+    /* On calcule la quantité de mana consommée par les compétences */
+    consume = prev_mana - room->player.mana;
+    /* On fait retourner cette quantité de mana sur des tuiles aléatoires
+     et dont les traces de mana avaient été absorbée */
+    for (i = 0; i < consume; i++){
+        place_random_mana_in_grid(&room->grid);
+    }
+}
+
+
+/* Permet de récupérer les reliques dans la salle 'room' */
+void take_relics_in_room(Room *room){
+    Case coord;
+    coord = point_case(room->player.disc.center);
+    if (is_relic(&room->grid, coord)){
+        room->grid.tab[coord.lin][coord.col] = RELIC_TAKEN;
+    }
 }
 
-/* Permet de vérifier si le joueur est détecté par un gardien dans la salle 'room' */
+
+/* Fait entrer les gardiens de la salle 'room' en mode panique */
+void guards_enter_panic_mode_in_room(Room *room){
+    int i;
+    for (i = 0; i < NB_GUARDS; i++){
+        enter_panic_mode(&room->guards[i]);
+    }
+}
+
+/* Fait entrer les gardiens de la salle 'room' en mode normal */
+void guards_enter_normal_mode_in_room(Room *room){
+    int i;
+    for (i = 0; i < NB_GUARDS; i++){
+        enter_normal_mode(&room->guards[i]);
+    }
+}
+
+/* Gère les modes des gardiens dans la salle 'room' */
+void manage_guards_modes_in_room(Room *room){
+    int i;
+    static int cmpt, panic = 0;
+
+    for (i = 0; i < NB_GUARDS; i++){
+        /* Si un gardien voit qu'une relique a disparu, on fait entrer tous les gardiens en mode panique */
+        if (detect_missing_relics(&room->guards[i], &room->grid)){
+            guards_enter_panic_mode_in_room(&(*room));
+            panic = 1; /* Mode panique activé */
+            cmpt = 0; /* On initialise une sorte de chrono */
+        }
+    }
+    /* Si le mode panique est activé, on laisse tourner le chrono */
+    if (panic){
+        cmpt++;
+        /* Après une certaine durée, les gardiens reviennent en mode normal */
+        /* (si NB_FRAMES_PER_S = 60, 30 secondes équivaut à 1800 tours de boucle du while dans le main) */
+        if (cmpt >= NB_FRAMES_PER_S * TIME_PC){
+            guards_enter_normal_mode_in_room(&(*room));
+            panic = 0;
+        }
+    }
+}
+
+
+/* Renvoie 1 si le joueur est détecté par un gardien dans la salle 'room', 0 sinon */
 int player_detected_in_room(const Room *room){
     int n;
     for (n = 0; n < NB_GUARDS ; n++){
-        if((wall_between_player_guard(&room->player, &room->guards[n], &room->grid) == 0) 
-            && player_in_zone(&room->player, &room->guards[n])){
+        /* Si le joueur est directement visible par un gardien et que sa compétence Invisibilité est désactivée
+           alors le joueur perd et la partie se termine */
+        if(!wall_between_point_guard(room->player.disc.center, &room->guards[n], &room->grid)
+            && player_in_zone(&room->player, &room->guards[n]) && room->player.comp.invisibility == UNUSED){
                 return 1;
         }
     }
     return 0;
-}
+}
\ No newline at end of file
diff --git a/GameEngine.h b/GameEngine.h
index 3a48523..bbfedee 100644
--- a/GameEngine.h
+++ b/GameEngine.h
@@ -9,6 +9,7 @@
 #include "Detection.h"
 #define NB_GUARDS 5 /* Nombre de gardiens */
 #define NB_RELICS 3 /* Nombre de reliques */
+#define NB_FRAMES_PER_S 60 /* Nombre de frames par seconde */
 
 typedef struct{
     Grid grid;
@@ -23,8 +24,15 @@ void move_guards_in_room(Room *room);
 
 void move_player(Player *player, const Grid *grid, Direction pressed);
 void move_player_in_room(Room *room);
+void absorb_mana(Player *player, Grid *grid);
+void absorb_manas_in_room(Room *room);
 void use_player_competences_in_room(Room *room);
-int player_detected_in_room(const Room *room);
+void take_relics_in_room(Room *room);
+
+void guards_enter_panic_mode_in_room(Room *room);
+void guards_enter_normal_mode_in_room(Room *room);
+void manage_guards_modes_in_room(Room *room);
 
+int player_detected_in_room(const Room *room);
 
 #endif
\ No newline at end of file
diff --git a/Grid.c b/Grid.c
index 9ec561f..8769459 100644
--- a/Grid.c
+++ b/Grid.c
@@ -48,4 +48,14 @@ int is_wall(const Grid *grid, Case coord){
 /* Renvoie 1 si la case 'coord' de la grille est une case de relique, 0 sinon */
 int is_relic(const Grid *grid, Case coord){
     return grid->tab[coord.lin][coord.col] == RELIC;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case de mana, 0 sinon */
+int is_mana(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == MANA;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case indiquant une relique prise, 0 sinon */
+int is_relic_taken(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == RELIC_TAKEN;
 }
\ No newline at end of file
diff --git a/Grid.h b/Grid.h
index f8b06d4..971968b 100644
--- a/Grid.h
+++ b/Grid.h
@@ -29,5 +29,7 @@ int is_empty(const Grid *grid, Case coord);
 int is_gap(const Grid *grid, Case coord);
 int is_wall(const Grid *grid, Case coord);
 int is_relic(const Grid *grid, Case coord);
+int is_mana(const Grid *grid, Case coord);
+int is_relic_taken(const Grid *grid, Case coord);
 
 #endif
\ No newline at end of file
diff --git a/Guard.h b/Guard.h
index 9114f90..d411456 100644
--- a/Guard.h
+++ b/Guard.h
@@ -12,6 +12,7 @@
 #define SPEED_PC V /* Vitesse d'un gardien en mode panique */
 #define DETECT_DIST_NL 4 /* Distance de détection d'un gardien en mode normal */
 #define DETECT_DIST_PC 6 /* Distance de détection d'un gardien en mode panique */
+#define TIME_PC 30 /* Durée du mode panique en seconde */
 
 typedef enum{
     NORMAL, /* Mode normal */
diff --git a/Main.c b/Main.c
index 2b7cda2..2fdfe09 100644
--- a/Main.c
+++ b/Main.c
@@ -15,7 +15,7 @@ int main(){
     MLV_create_window("Game", "Game", WINDOW_WIDTH, WINDOW_HEIGHT);
 
     /* Boucle maîtresse gérant le jeu frame par frame 
-     (le programme doit faire 60 frames par seconde) */
+     (le programme doit faire NB_FRAMES_PER_S frames par seconde) */
     while(1){
         struct timespec end_time, new_time;
         double frametime, extratime;
@@ -24,10 +24,20 @@ int main(){
 
         /* Affichage de la frame courante */
         draw_room(&room);
+
+        /* Gère les mécanismes du jeu */
         move_guards_in_room(&room);
         move_player_in_room(&room);
+        absorb_manas_in_room(&room);
         use_player_competences_in_room(&room);
+        take_relics_in_room(&room);
+        manage_guards_modes_in_room(&room);
+
 
+        if (player_detected_in_room(&room)){
+            printf("perdu\n"); 
+            break;
+        }
 
         /* On récupère le temps en nanoseconde à la fin de la frame */
         clock_gettime(CLOCK_REALTIME, &new_time);
@@ -36,8 +46,8 @@ int main(){
         frametime = new_time.tv_sec - end_time.tv_sec;
         frametime += (new_time.tv_sec - end_time.tv_sec) / 1.0E9;
 
-        /* On force le programme à passer au moins 1/60 seconde au total */
-        extratime = 1.0 / 60 - frametime;
+        /* On force le programme à passer au moins 1/NB_FRAMES_PER_S seconde au total */
+        extratime = 1.0 / NB_FRAMES_PER_S - frametime;
         if (extratime > 0){
             MLV_wait_milliseconds((int) (extratime * 1000));
         }
diff --git a/Player.c b/Player.c
index 5a48da7..7940b4c 100644
--- a/Player.c
+++ b/Player.c
@@ -67,12 +67,14 @@ void desactivate_acceleration(Player *player){
 /* Fait utiliser la compétence Accélération du joueur 'player' donc du mana est consommé */
 void use_acceleration(Player *player){
     if (player->comp.acceleration == USED && player->mana >= ACC_MANA) player->mana -= ACC_MANA;
-    else desactivate_acceleration(&(*player));
+    if (player->mana < ACC_MANA) desactivate_acceleration(&(*player));
 }
 
 /* Active la compétence Invisibilité du joueur 'player' */
 void activate_invisibility(Player *player){
-    if (player->mana >= INV_MANA && player->comp.invisibility == UNUSED) player->comp.invisibility = USED; 
+    if (player->mana >= INV_MANA && player->comp.invisibility == UNUSED){
+        player->comp.invisibility = USED;
+    }
 }
 
 /* Désactive la compétence Invisibilité du joueur 'player' */
@@ -82,6 +84,8 @@ void desactivate_invisibility(Player *player){
 
 /* Fait utiliser la compétence Invisibilité du joueur 'player' donc du mana est consommé */
 void use_invisibility(Player *player){
-    if (player->comp.invisibility == USED && player->mana >= INV_MANA) player->mana -= INV_MANA;
-    else desactivate_invisibility(&(*player));
+    if (player->comp.invisibility == USED && player->mana >= INV_MANA){
+        player->mana -= INV_MANA;
+    }
+    if (player->mana < INV_MANA) desactivate_invisibility(&(*player));
 }
diff --git a/Point.c b/Point.c
index 25deea7..7097e13 100644
--- a/Point.c
+++ b/Point.c
@@ -2,7 +2,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
-#define SQUARE(x) ((x) * (x))
 
 
 /* Calcule la distance euclidienne entre les points 'a' et 'b' */
@@ -10,7 +9,7 @@ double distance(Point a, Point b){
     double dx, dy;
     dx = b.x - a.x;
     dy = b.y - a.y;
-    return sqrt(SQUARE(dx) + SQUARE(dy));
+    return sqrt(pow(dx, 2) + pow(dy, 2));
 }
 
 /* Renvoie un entier aléatoire entre les entiers 'a' et 'b' (tous deux compris) */
@@ -32,6 +31,8 @@ double random_double(int a, int b){
  * La coordonnée x (resp. y) du point est entre 'x1' et 'x2' (resp. 'y1' et 'y2').
 */
 Point random_point(int x1, int x2, int y1, int y2){
-    Point point = {random_double(x1, x2), random_double(y1, y2)};
+    Point point;
+    point.x = random_double(x1, x2);
+    point.y = random_double(y1, y2);
     return point;
 }
\ No newline at end of file
diff --git a/Terrain.c b/Terrain.c
index 4974132..85700c4 100644
--- a/Terrain.c
+++ b/Terrain.c
@@ -1,13 +1,14 @@
 #include "Terrain.h"
 #include <stdio.h>
 #include <stdlib.h>
+#include <math.h>
 
 
 /* Génère un mur vertical dans la grille 'grid' de la ligne 'start_y' à la ligne 'end_y' à la colonne n°'column' */
 void generate_vertical_wall(Grid *grid, int column, int start_y, int end_y){
     int i, alea;
 
-    alea = rand() % 2; /* Permet de savoir à quelle extrémité du mur les cases d'ouvertures doivent être placées */
+    alea = rand() % 2; /* Pour savoir à quelle extrémité du mur les cases d'ouvertures doivent être placées */
     for (i = start_y; i <= end_y; i++){
         grid->tab[i][column] = WALL;
         if (alea == 0 && i < start_y + LENGTH_GAP) grid->tab[i][column] = GAP;
@@ -19,7 +20,7 @@ void generate_vertical_wall(Grid *grid, int column, int start_y, int end_y){
 void generate_horizontal_wall(Grid *grid, int line, int start_x, int end_x){
     int i, alea;
 
-    alea = rand() % 2; /* Permet de savoir à quelle extrémité du mur les cases d'ouvertures doivent être placées */
+    alea = rand() % 2; /* Pour savoir à quelle extrémité du mur les cases d'ouvertures doivent être placées */
     for (i = start_x; i <= end_x; i++){
         grid->tab[line][i] = WALL;
         if (alea == 0 && i < start_x + LENGTH_GAP) grid->tab[line][i] = GAP;
@@ -85,15 +86,12 @@ int far_enough_from_the_player(Point point, const Player *player){
     return distance(point, player->disc.center) >= MINDIST;
 }
 
-/* Renvoie la partie entière de 'd' */
-int integer(double d){
-    return (int) d;
-}
-
 /* Renvoie la case contenant le point 'point' */
 Case point_case(Point point){
-    Case _case = {integer(point.y / SIZE_CASE), integer(point.x / SIZE_CASE)};
-    return _case;
+    Case c;
+    c.lin = floor(point.y / SIZE_CASE);
+    c.col = floor(point.x / SIZE_CASE);
+    return c;
 }
 
 /* Redimensionne les coordonnées du point 'point' pour l'adapter aux dimensions "réelles" du terrain */
@@ -136,6 +134,24 @@ void place_manas_in_grid(Grid *grid){
     }
 }
 
+/* Place une tuile de mana aléatoirement dans la grille 'grid' */
+void place_random_mana_in_grid(Grid *grid){
+    int valid;
+    Point point;
+    Case coord;
+
+    valid = 0;
+    while (!valid){
+        point = random_point(1, NB_COL - 2, 1, NB_LIN - 2);
+        resize_point(&point);
+        coord = point_case(point);
+        if (is_empty(&(*grid), coord)){
+            grid->tab[coord.lin][coord.col] = MANA;
+            valid = 1;
+        }
+    }
+}
+
 
 /* Renvoie 1 si le gardien 'guard' touche ou se superpose à un autre gardien de 'tab' de taille 'size'.
  * 'index' est l'indice du gardien 'guard' dans le tableau 'tab'.
@@ -143,7 +159,10 @@ void place_manas_in_grid(Grid *grid){
 int superposition_between_guards(const Guard *guard, int index, const Guard *tab, int size){
     int i;
     for (i = 0; i < size; i++){
-        if (i != index && superposition_between_discs(guard->disc, tab[i].disc)) return 1;
+        /* On ne compare pas le gardien 'guard' à lui-même */
+        if (i != index){
+            if (superposition_between_discs(guard->disc, tab[i].disc)) return 1;
+        }
     }
     return 0;
 }
diff --git a/Terrain.h b/Terrain.h
index e050de9..b871e85 100644
--- a/Terrain.h
+++ b/Terrain.h
@@ -23,12 +23,12 @@ void generate_compartments(Grid *grid, int x, int start_x, int end_x, int y, int
 void place_player_in_grid(Player *player);
 
 int far_enough_from_the_player(Point point, const Player *player);
-int integer(double d);
 Case point_case(Point point);
 void resize_point(Point *point);
 
 void place_relics_in_grid(int nb_relics, Grid *grid, const Player *player);
 void place_manas_in_grid(Grid *grid);
+void place_random_mana_in_grid(Grid *grid);
 
 int superposition_between_guards(const Guard *guard, int index, const Guard *tab, int size);
 int in_diagonal_wall(const Guard *guard, const Grid *grid);
diff --git a/makefile b/makefile
index 2869ad2..e5ce961 100644
--- a/makefile
+++ b/makefile
@@ -26,7 +26,7 @@ Terrain.o: Terrain.c Terrain.h Grid.h Point.h Disc.h Player.h Guard.h
 
 Collision.o: Collision.c Collision.h Point.h Disc.h Direction.h Grid.h Terrain.h Guard.h
 
-Detection.o: Detection.c Detection.h Guard.h Player.h Grid.h
+Detection.o: Detection.c Detection.h Point.h Disc.h Guard.h Player.h Grid.h Terrain.h
 
 GameEngine.o: GameEngine.c GameEngine.h Grid.h Player.h Guard.h Terrain.h Collision.h Detection.h
 

commit 470f7d77908724badab792d098ccdc0490dfbe86
Author: lina GUERROUI <padawan@DebianUPEM2019.padawan>
Date:   Wed Jan 11 23:42:13 2023 +0100

    modification Detection pour inclure la détection des reliques disparues par les gardiens

diff --git a/Detection.c b/Detection.c
index 598a692..e251dc7 100644
--- a/Detection.c
+++ b/Detection.c
@@ -66,18 +66,18 @@ Case point_to_case(double x, double y){
     return c;
 }
 
-/*1- trouve les points de croisement entre le segment [p0, p1] avec les axes
+/*p0 = 'center' et p1 = centre du gardien 'guard'
+  1- trouve les points de croisement entre le segment [p0, p1] avec les axes
   2- les convertir en case + case adjacente
-  3- renvoie 1 si le joueur est detecté par le gardien,
-     sinon 0 (car il y a un mur ou il n'appartient pas à la zone de détection) */
-int wall_between_player_guard(const Player *player, const Guard *guard, const Grid *grid){
+  3- renvoie 1 si l'une de ces cases est un mur, sinon 0 */
+int wall_between_point_guard(Point center, const Guard *guard, const Grid *grid){
     int i, j;
     double pa, ya, pb, yb;
     Point point_highest, point_lower;
 
     /* les points du croisement entre abscisse et segment x = a (= i) */
-    point_highest = copy_point( x_higher(player->disc.center, guard->disc.center));
-    point_lower = copy_point(x_lower(player->disc.center, guard->disc.center));
+    point_highest = copy_point( x_higher(center, guard->disc.center));
+    point_lower = copy_point(x_lower(center, guard->disc.center));
 
     for ( i = floor(point_highest.x); i < floor(point_lower.x) + 1; i++ ){
         pa = position_Pa(i , point_highest, point_lower);
@@ -91,8 +91,8 @@ int wall_between_player_guard(const Player *player, const Guard *guard, const Gr
         }
     }
     /* les points du croisement entre ordonnée et segment y = b (= j) */
-    point_highest = copy_point( y_higher(player->disc.center, guard->disc.center));
-    point_lower = copy_point(y_lower(player->disc.center, guard->disc.center));
+    point_highest = copy_point( y_higher(center, guard->disc.center));
+    point_lower = copy_point(y_lower(center, guard->disc.center));
     for ( j = floor(point_highest.y); j < floor(point_lower.y) + 1 ; j++ ){
         pb = position_Pb(j , point_highest, point_lower);
         if( p_in_segment(pb)){
@@ -116,3 +116,32 @@ int player_in_zone(const Player *player, const Guard *guard){
     }
     return 0;
 }
+
+/* renvoie 1 si le gardien 'guard' détecte qu'une relique a disparu dans la grille, sinon 0 */
+int detect_missing_relics(const Guard *guard, Grid *grid){
+    int i, j;
+    Disc disc; /* disque avec pour rayon la distance de détection du gardien */
+    Point middle;
+
+    disc.center = guard->disc.center;
+    disc.radius = guard->detection_dist * SIZE_CASE;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            /* pour chaque case, on calcule les coordonnées du milieu dans un point */
+            Case coord = {i, j};
+            middle.x = coord.col + (1 / (double) 2);
+            middle.y = coord.lin + (1 / (double) 2);
+            resize_point(&middle);
+            if (point_inside_disc(middle, disc)){
+                if (!wall_between_point_guard(middle, &(*guard), &(*grid))){
+                    if (is_relic_taken(&(*grid), coord)){
+                        /* on met cette relique comme étant déjà détectée */
+                        grid->tab[coord.lin][coord.col] = RELIC_DETECT;
+                        return 1;
+                    }
+                }
+            }
+        }
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/Detection.h b/Detection.h
index f9526e0..d44c39f 100644
--- a/Detection.h
+++ b/Detection.h
@@ -1,9 +1,12 @@
 #ifndef __DETECTION__
 #define __DETECTION__
 
+#include "Point.h"
+#include "Disc.h"
 #include "Guard.h"
 #include "Player.h"
 #include "Grid.h"
+#include "Terrain.h"
 
 
 double position_Pa(int a, Point point_0, Point point_1);
@@ -17,7 +20,8 @@ Point y_higher(const Point point_1, const Point point_2);
 Point y_lower(const Point point_1, const Point point_2);
 Point copy_point(const Point point);
 Case point_to_case(double x, double y);
-int wall_between_player_guard(const Player *player, const Guard *guard, const Grid *grid);
+int wall_between_point_guard(Point center, const Guard *guard, const Grid *grid);
 int player_in_zone(const Player *player, const Guard *guard);
+int detect_missing_relics(const Guard *guard, Grid *grid);
 
 #endif
\ No newline at end of file
diff --git a/Grid.h b/Grid.h
index 64f6f4a..f8b06d4 100644
--- a/Grid.h
+++ b/Grid.h
@@ -15,7 +15,8 @@ typedef enum{
     GAP, /* Ouverture */
     MANA, /* Traces de mana */
     RELIC, /* Relique */
-    RELIC_TAKEN /* Relique prise */
+    RELIC_TAKEN, /* Relique prise */
+    RELIC_DETECT /* Relique détectée */
 } InfoCase; /* Donne une information sur une case */
 
 typedef struct{

commit cb5966a3a9c814d6e41093e01d55c4bab7d057e0
Author: lina GUERROUI <padawan@DebianUPEM2019.padawan>
Date:   Wed Jan 11 19:52:26 2023 +0100

    - makefile

diff --git a/makefile b/makefile
index f4c361d..2869ad2 100644
--- a/makefile
+++ b/makefile
@@ -3,7 +3,7 @@ CC=gcc
 CFLAGS=-ansi -Wall
 LDFLAGS=-lm -lMLV
 EXEC=exec
-OBJ=Main.o Direction.o Point.o Disc.o Player.o Guard.o Grid.o Terrain.o Collision.o GameEngine.o Graphic.o
+OBJ=Main.o Direction.o Point.o Disc.o Player.o Guard.o Grid.o Terrain.o Collision.o Detection.o GameEngine.o Graphic.o
 
 $(EXEC): $(OBJ)
 	$(CC) -g -o $@ $^ $(CFLAGS) $(LDFLAGS)
@@ -26,7 +26,9 @@ Terrain.o: Terrain.c Terrain.h Grid.h Point.h Disc.h Player.h Guard.h
 
 Collision.o: Collision.c Collision.h Point.h Disc.h Direction.h Grid.h Terrain.h Guard.h
 
-GameEngine.o: GameEngine.c GameEngine.h Grid.h Player.h Guard.h Terrain.h Collision.h
+Detection.o: Detection.c Detection.h Guard.h Player.h Grid.h
+
+GameEngine.o: GameEngine.c GameEngine.h Grid.h Player.h Guard.h Terrain.h Collision.h Detection.h
 
 Graphic.o: Graphic.c Graphic.h GameEngine.h
 

commit 0e464b6be50bb3ffb02ca4c84c6d1acd2dc65e44
Author: lina GUERROUI <padawan@DebianUPEM2019.padawan>
Date:   Wed Jan 11 19:48:52 2023 +0100

    -création module Detection + modification GameEngine: détection du joueur par les gardiens; makefile

diff --git a/Detection.c b/Detection.c
new file mode 100644
index 0000000..598a692
--- /dev/null
+++ b/Detection.c
@@ -0,0 +1,118 @@
+#include "Detection.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+
+/* calcule la position relative d'un point Pa par raport à l'abscisse (x = a) */
+double position_Pa(int a, Point point_0, Point point_1 ){
+    return (a - point_1.x ) / (point_0.x - point_1.x);
+}
+
+/* calcule la position relative d'un point Pb par raport à l'ordonnée (y = b) */
+double position_Pb(int b, Point point_0, Point point_1 ){
+    return (b - point_1.y ) / (point_0.y - point_1.y);
+}
+
+/* vérification : 1 si la position relative appartient au segment [P0,P1] sinon 0 */
+int p_in_segment(double p){
+    return (p >= 0 && p <= 1);
+}
+
+/* calcule de l'ordonnée(y) du point Pa */
+double ordinate_Pa(int a, Point point_0, Point point_1 ){ 
+    return (point_1.y + ((point_0.y - point_1.y) / (point_0.x - point_1.x))* (a - point_1.x));
+}
+
+/* calcule de l'abscisse(x) du point Pb */
+double abscissa_Pb(int b, Point point_0, Point point_1 ){ 
+    return (point_1.x + ((point_0.x - point_1.x) / (point_0.y - point_1.y))* (b - point_1.y));
+}
+
+
+/* trouve le point qu'a le x plus petit (le plus haut) */
+Point x_higher(const Point point_1, const Point point_2){
+    return (point_1.x < point_2.x)? point_1 : point_2;
+}
+
+/* trouve le point qu'a le x plus grand (le plus bas) */
+Point x_lower(const Point point_1, const Point point_2){
+    return (point_1.x < point_2.x)? point_2 : point_1;
+}
+
+/* trouve le point qu'a le y plus petit (le plus haut) */
+Point y_higher(const Point point_1, const Point point_2){
+    return (point_1.y < point_2.y)? point_1 : point_2;
+}
+
+/* trouve le point qu'a le y plus grand (le plus bas) */
+Point y_lower(const Point point_1, const Point point_2){
+    return (point_1.y < point_2.y)? point_2 : point_1;
+}
+
+/* copie un point dans un nouveau point */
+Point copy_point(const Point point){
+    Point p;
+    p.x = point.x;
+    p.y = point.y;
+    return p;
+}
+
+/* case traversée à partir d'un point de croisement des droites avec un coté d'un carré par le segment [po, p1] */
+Case point_to_case(double x, double y){
+    Case c;
+    c.col = floor(x / SIZE_CASE);
+    c.lin = floor(y / SIZE_CASE);    
+    return c;
+}
+
+/*1- trouve les points de croisement entre le segment [p0, p1] avec les axes
+  2- les convertir en case + case adjacente
+  3- renvoie 1 si le joueur est detecté par le gardien,
+     sinon 0 (car il y a un mur ou il n'appartient pas à la zone de détection) */
+int wall_between_player_guard(const Player *player, const Guard *guard, const Grid *grid){
+    int i, j;
+    double pa, ya, pb, yb;
+    Point point_highest, point_lower;
+
+    /* les points du croisement entre abscisse et segment x = a (= i) */
+    point_highest = copy_point( x_higher(player->disc.center, guard->disc.center));
+    point_lower = copy_point(x_lower(player->disc.center, guard->disc.center));
+
+    for ( i = floor(point_highest.x); i < floor(point_lower.x) + 1; i++ ){
+        pa = position_Pa(i , point_highest, point_lower);
+        if( p_in_segment(pa) ){
+            ya = ordinate_Pa( i, point_highest, point_lower );
+            /* si une case adjacente du point est mur */
+            if(is_wall(grid, point_to_case(i, ya)) 
+                || is_wall(grid, point_to_case(i - 1, ya))){
+                return 1;
+            }
+        }
+    }
+    /* les points du croisement entre ordonnée et segment y = b (= j) */
+    point_highest = copy_point( y_higher(player->disc.center, guard->disc.center));
+    point_lower = copy_point(y_lower(player->disc.center, guard->disc.center));
+    for ( j = floor(point_highest.y); j < floor(point_lower.y) + 1 ; j++ ){
+        pb = position_Pb(j , point_highest, point_lower);
+        if( p_in_segment(pb)){
+            yb = abscissa_Pb(j , point_highest, point_lower);
+            /* si une case adjacente du point est mur */
+            if(is_wall(grid, point_to_case(yb, j)) 
+                || is_wall(grid, point_to_case(yb, j - 1))){
+                    return 1;
+            }
+        }
+    }
+    return 0;
+}
+
+/* vérifie si le centre de player est dans la zone de détection du guard */
+int player_in_zone(const Player *player, const Guard *guard){
+    double dist; /* distance entre le centre du player et le centre du guard */
+    dist = distance(player->disc.center, guard->disc.center) ;
+    if (dist <= ((guard->detection_dist) * SIZE_CASE)){
+        return 1;
+    }
+    return 0;
+}
diff --git a/Detection.h b/Detection.h
new file mode 100644
index 0000000..f9526e0
--- /dev/null
+++ b/Detection.h
@@ -0,0 +1,23 @@
+#ifndef __DETECTION__
+#define __DETECTION__
+
+#include "Guard.h"
+#include "Player.h"
+#include "Grid.h"
+
+
+double position_Pa(int a, Point point_0, Point point_1);
+double position_Pb(int b, Point point_0, Point point_1);
+int p_in_segment(double p);
+double ordinate_Pa(int a, Point point_0, Point point_1);
+double abscissa_Pb(int b, Point point_0, Point point_1);
+Point x_higher(const Point point_1, const Point point_2);
+Point x_lower(const Point point_1, const Point point_2);
+Point y_higher(const Point point_1, const Point point_2);
+Point y_lower(const Point point_1, const Point point_2);
+Point copy_point(const Point point);
+Case point_to_case(double x, double y);
+int wall_between_player_guard(const Player *player, const Guard *guard, const Grid *grid);
+int player_in_zone(const Player *player, const Guard *guard);
+
+#endif
\ No newline at end of file
diff --git a/GameEngine.c b/GameEngine.c
index 1284373..977d7d8 100644
--- a/GameEngine.c
+++ b/GameEngine.c
@@ -78,9 +78,8 @@ void move_player(Player *player, const Grid *grid, Direction pressed){
         /* Fait en sorte que le joueur ne rentre pas en collision avec un mur */
         change_position_player(&(*player));
         collide_wall(&player->disc, player->dir, limit);
-        return;
     }
-    change_position_player(&(*player));
+    else change_position_player(&(*player));
 }
 
 /* Renvoie 1 si la touche 'key' du clavier a été pressée, 0 sinon */
@@ -128,4 +127,16 @@ void use_player_competences_in_room(Room *room){
     }
     if (!acc) desactivate_acceleration(&room->player);
     if (!inv) desactivate_invisibility(&room->player);
-}
\ No newline at end of file
+}
+
+/* Permet de vérifier si le joueur est détecté par un gardien dans la salle 'room' */
+int player_detected_in_room(const Room *room){
+    int n;
+    for (n = 0; n < NB_GUARDS ; n++){
+        if((wall_between_player_guard(&room->player, &room->guards[n], &room->grid) == 0) 
+            && player_in_zone(&room->player, &room->guards[n])){
+                return 1;
+        }
+    }
+    return 0;
+}
diff --git a/GameEngine.h b/GameEngine.h
index 708d5d9..3a48523 100644
--- a/GameEngine.h
+++ b/GameEngine.h
@@ -6,6 +6,7 @@
 #include "Guard.h"
 #include "Terrain.h"
 #include "Collision.h"
+#include "Detection.h"
 #define NB_GUARDS 5 /* Nombre de gardiens */
 #define NB_RELICS 3 /* Nombre de reliques */
 
@@ -19,8 +20,11 @@ void initialize_room(Room *room);
 
 void move_guard(Guard *guard, int index, const Guard *tab, int size, const Grid *grid);
 void move_guards_in_room(Room *room);
+
 void move_player(Player *player, const Grid *grid, Direction pressed);
 void move_player_in_room(Room *room);
 void use_player_competences_in_room(Room *room);
+int player_detected_in_room(const Room *room);
+
 
 #endif
\ No newline at end of file

commit cc0fe38968641a7b90ca5f2ea59525ccee955885
Author: Sylvain Tran <sylvain.tran@etud.u-pem.fr>
Date:   Tue Jan 10 06:27:21 2023 +0100

    Détection de collision avec les murs; Déplacement aléatoire des gardiens dans la salle; Déplacement du joueur dans la salle avec touches zqsd + Compétences

diff --git a/Collision.c b/Collision.c
new file mode 100644
index 0000000..7885cc0
--- /dev/null
+++ b/Collision.c
@@ -0,0 +1,204 @@
+#include "Collision.h"
+#include <stdio.h>
+#include <math.h>
+
+
+/* Détermine et récupère les 3 cases ('front', 'front_side1' et 'front_side2') en face de l'agent 'agent' 
+ * suivant la direction du déplacement 'dir' et à une distance 'dist' de celui-ci.
+ * Par exemple,
+ * Si 'dist' = 0, les 3 cases récupérées sont celles immédiatements situées en face de l'agent 'agent'.
+ * Si 'dist' = 1, ce sont les 3 cases situées 1 case plus loin qui sont récupérées
+*/
+void determine_front_cases(Disc agent, Direction dir, int dist, Case *front, Case *front_side1, Case *front_side2){
+    Case coord; /* Case contenant le centre du disque 'agent' */
+    int offset_lin[] = {-(1 + dist), 1 + dist, 0, 0};
+    int offset_col[] = {0, 0, -(1 + dist), 1 + dist};
+    int lin, col;
+    coord = point_case(agent.center);
+
+    /* Pour Haut et Bas, les 3 cases ont la même ligne. Seule la colonne change */
+    if (dir == UP || dir == DOWN){
+        lin = coord.lin + offset_lin[dir];
+        front->lin = front_side1->lin = front_side2->lin = lin;
+        front->col = coord.col; /* Case devant */
+        front_side1->col = coord.col - 1; /* Case devant à gauche */
+        front_side2->col = coord.col + 1; /* Case devant à droite */
+    }
+
+    /* Pour Gauche et Droite, les 3 cases ont la même colonne. Seule la ligne change */
+    else if (dir == LEFT || dir == RIGHT){
+        col = coord.col + offset_col[dir];
+        front->lin = coord.lin; /* Case devant */
+        front_side1->lin = coord.lin - 1; /* Case devant en haut */
+        front_side2->lin = coord.lin + 1; /* Case devant en bas */
+        front->col = front_side1->col = front_side2->col = col;
+    }
+}
+
+/* Renvoie 1 si l'agent 'agent' risque d'entrer en collision avec un mur dans la grille 'grid' 
+ * situé à distance 'dist' de celui-ci suivant sa direction 'dir', 0 sinon 
+*/
+int risk_collide_wall(Disc agent, Direction dir, int dist, const Grid *grid){
+    Case f, f_s1, f_s2;
+    determine_front_cases(agent, dir, dist, &f, &f_s1, &f_s2);
+    if (is_wall(&(*grid), f) || is_wall(&(*grid), f_s1) || is_wall(&(*grid), f_s2)) return 1;
+    return 0;
+}
+
+
+/* Redimensionne la coordonnée 'x' pour l'adapter aux dimensions "réduites" du terrain */
+void resize_mini_coordinate(double *x){
+    *x /= SIZE_CASE;
+}
+
+/* Redimensionne la coordonnée 'x' pour l'adapter aux dimensions "réelles" du terrain */
+void resize_real_coordinate(double *x){
+    *x *= SIZE_CASE;
+}
+
+
+/* Renvoie 1 si une limite de déplacement en y a été calculée pour l'agent 'agent', 0 sinon.
+ * Si c'est le cas, cette limite est récupérée avec 'ymax'
+*/
+int travel_limit_in_y(Disc agent, Direction dir, int dist, const Grid *grid, double *ymax){
+    Case f, f_s1, f_s2; /* Les 3 cases de devant à distance 'dist' du disque 'agent' suivant 'dir' */
+    Case coord; /* Case contenant le centre du disque 'agent' */
+    int x, y; /* Coordonnées du coin en haut à gauche de 'coord' */
+    double x0; /* Coordonnée x du centre du disque 'agent' */
+    double mid; /* Coordonnée du milieu du segment [⌊x0⌋, ⌊x0⌋ + 1] */
+    double height; /* Hauteur (du triangle) à additionner ou à soustraire à 'ymax' */
+    int limit; /* limit = 1 si une limite de déplacement a été calculée */
+    
+    determine_front_cases(agent, dir, dist, &f, &f_s1, &f_s2);
+    coord = point_case(agent.center);
+    x = coord.col;
+    y = coord.lin;
+    x0 = agent.center.x;
+    mid = x + (1 / (double) 2);
+    resize_real_coordinate(&mid);
+    limit = 0;
+
+    /* 1ER Cas: */
+    if (is_wall(&(*grid), f_s1) && x0 < mid){
+        resize_mini_coordinate(&x0);
+        height = sqrt(1 / (double)4 - pow(x0 - x, 2));
+        
+        if (dir == DOWN) *ymax = y + 1 - height;
+        else if (dir == UP) *ymax = y + height;
+        limit = 1;
+    }
+    /* 2ND Cas: */
+    if (is_wall(&(*grid), f_s2) && x0 > mid){
+        resize_mini_coordinate(&x0);
+        height = sqrt(1 / (double)4 - pow(x + 1 - x0, 2));
+
+        if (dir == DOWN) *ymax = y + 1 - height;
+        else if (dir == UP) *ymax = y + height;
+        limit = 1;
+    }
+    /* 3ÈME Cas: */
+    if (is_wall(&(*grid), f)){
+        *ymax = y + (1 / (double) 2);
+        limit = 1;
+    }
+    resize_real_coordinate(&(*ymax));
+    if (limit) return 1;
+    return 0;
+}
+
+/* Renvoie 1 si une limite de déplacement en x a été calculée pour l'agent 'agent', 0 sinon.
+ * Si c'est le cas, cette limite est récupérée avec 'xmax'
+*/
+int travel_limit_in_x(Disc agent, Direction dir, int dist, const Grid *grid, double *xmax){
+    Case f, f_s1, f_s2; /* Les 3 cases de devant à distance 'dist' du disque 'agent' suivant 'dir' */
+    Case coord; /* Case contenant le centre du disque 'agent' */
+    int x, y; /* Coordonnées du coin en haut à gauche de 'coord' */
+    double y0; /* Coordonnée y du centre du disque 'agent' */
+    double mid; /* Coordonnée du milieu du segment [⌊y0⌋, ⌊y0⌋ + 1] */
+    double height; /* Hauteur (du triangle) à additionner ou à soustraire à 'xmax' */
+    int limit; /* limit = 1 si une limite de déplacement a été calculée */
+
+    determine_front_cases(agent, dir, dist, &f, &f_s1, &f_s2);
+    coord = point_case(agent.center);
+    x = coord.col;
+    y = coord.lin;
+    y0 = agent.center.y;
+    mid = y + (1 / (double) 2);
+    resize_real_coordinate(&mid);
+    limit = 0;
+
+    /* 1ER Cas: */
+    if (is_wall(&(*grid), f_s1) && y0 < mid){
+        resize_mini_coordinate(&y0);
+        height = sqrt(1 / (double)4 - pow(y0 - y, 2));
+
+        if (dir == RIGHT) *xmax = x + 1 - height;
+        else if (dir == LEFT) *xmax = x + height;
+        limit = 1;
+    }
+    /* 2ND Cas: */
+    if (is_wall(&(*grid), f_s2) && y0 > mid){
+        resize_mini_coordinate(&y0);
+        height = sqrt(1 / (double)4 - pow(y + 1 - y0, 2));
+
+        if (dir == RIGHT) *xmax = x + 1 - height;
+        else if (dir == LEFT) *xmax = x + height;
+        limit = 1;
+    }
+    /* 3ÈME Cas: */
+    if (is_wall(&(*grid), f)){
+       *xmax = x + (1 / (double) 2);
+        limit = 1;
+    }
+    resize_real_coordinate(&(*xmax));
+    if (limit) return 1;
+    return 0;
+}
+
+/* Renvoie 1 si une limite de déplacement (en x ou en y suivant
+ * la direction du déplacement 'dir') a été calculée pour l'agent 'agent', 0 sinon.
+ * Si c'est le cas, cette limite est récupérée avec 'limit'
+*/
+int travel_limit(Disc agent, Direction dir, int dist, const Grid *grid, double *limit){
+    if (dir == UP || dir == DOWN){
+        if (travel_limit_in_y(agent, dir, dist, &(*grid), &(*limit))) return 1;
+    }
+    else if (dir == LEFT || dir == RIGHT){
+        if (travel_limit_in_x(agent, dir, dist, &(*grid), &(*limit))) return 1;
+    }
+    return 0;
+}
+
+
+/* Renvoie 1 (0 sinon) si l'agent 'agent' est entré en collision avec un mur dans la direction 'dir' 
+ * c'est-à-dire si l'une de ces coordonnées a dépassée la limite qui lui a été imposée par 'limit' 
+*/
+int collide_wall(Disc *agent, Direction dir, double limit){
+    if ((dir == UP && agent->center.y < limit) || (dir == DOWN && agent->center.y > limit)){
+        agent->center.y = limit;
+        return 1;
+    }
+    else if ((dir == LEFT && agent->center.x < limit) || (dir == RIGHT && agent->center.x > limit)){
+        agent->center.x = limit;
+        return 1;
+    }
+    return 0;
+}
+
+/* Renvoie 1 si le gardien 'guard' est entré en collision avec un autre gardien dans 'tab' de taille 'size', 0 sinon.
+ * 'index' est l'indice du gardien 'guard' dans le tableau 'tab'
+*/
+int collide_guard(Guard *guard, int index, const Guard *tab, int size){
+    double x0, y0;
+    int collide; /* = 1 si le gardien 'guard' entre en collision avec un autre gardien dans 'tab' */
+    x0 = guard->disc.center.x;
+    y0 = guard->disc.center.y;
+    collide = 0;
+
+    change_position_guard(&(*guard));
+    if (superposition_between_guards(&(*guard), index, tab, size)) collide = 1;
+    guard->disc.center.x = x0; /* 'guard' récupère son ancienne coordonnée x */
+    guard->disc.center.y = y0; /* 'guard' récupère son ancienne coordonnée y */
+    if (collide) return 1;
+    return 0;
+}
diff --git a/Collision.h b/Collision.h
new file mode 100644
index 0000000..97a78ab
--- /dev/null
+++ b/Collision.h
@@ -0,0 +1,23 @@
+#ifndef __COLLISION__
+#define __COLLISION__
+
+#include "Point.h"
+#include "Disc.h"
+#include "Direction.h"
+#include "Grid.h"
+#include "Terrain.h"
+#include "Guard.h"
+
+void determine_front_cases(Disc agent, Direction dir, int dist, Case *front, Case *front_side1, Case *front_side2);
+int risk_collide_wall(Disc agent, Direction dir, int dist, const Grid *grid);
+
+void resize_mini_coordinate(double *x);
+void resize_real_coordinate(double *x);
+int travel_limit_in_y(Disc agent, Direction dir, int dist, const Grid *grid, double *ymax);
+int travel_limit_in_x(Disc agent, Direction dir, int dist, const Grid *grid, double *xmax);
+int travel_limit(Disc agent, Direction dir, int dist, const Grid *grid, double *limit);
+
+int collide_wall(Disc *agent, Direction dir, double limit);
+int collide_guard(Guard *guard, int index, const Guard *tab, int size);
+
+#endif
\ No newline at end of file
diff --git a/GameEngine.c b/GameEngine.c
index ef44f6b..1284373 100644
--- a/GameEngine.c
+++ b/GameEngine.c
@@ -1,5 +1,7 @@
 #include "GameEngine.h"
+#include <MLV/MLV_all.h>
 #include <stdio.h>
+#include <stdlib.h>
 
 
 /* Initialise la salle 'room' */
@@ -20,6 +22,110 @@ void initialize_room(Room *room){
     /* Gardiens */
     for (i = 0; i < NB_GUARDS; i++){
         initialize_guard(&room->guards[i]);
-        place_guard_in_grid(&room->guards[i], i, room->guards, NB_GUARDS, room->grid, &room->player);
+        place_guard_in_grid(&room->guards[i], i, room->guards, NB_GUARDS, &room->grid, &room->player);
     }
+}
+
+
+/* Déplace le gardien 'guard' dans la grille 'grid' en prenant en compte les autres gardiens dans 'tab' de taille 'size'.
+ * 'index' est l'indice du gardien 'guard' dans le tableau 'tab'
+*/
+void move_guard(Guard *guard, int index, const Guard *tab, int size, const Grid *grid){
+    int dist; /* La distance entre le gardien 'guard' et les 3 murs face à lui
+               suivant sa direction, dont il cherche à éviter la collision */
+    double limit; /* Limite de déplacement (en x ou y) */
+    dist = 0;
+
+    if (collide_guard(&(*guard), index, tab, size)){
+        change_direction_speed_guard(&(*guard));
+        return;
+    }
+
+    /* On veut qu'un gardien en mode panique change de direction si un mur est à une case de distance
+     (donc pas directement devant lui mais 1 case plus loin) */
+    if (guard->mode == PANIC && !risk_collide_wall(guard->disc, guard->dir, 0, &(*grid))) dist = 1;
+
+    if (travel_limit(guard->disc, guard->dir, dist, &(*grid), &limit)){
+        /* Si une limite de déplacement a été calculée, 
+         on regarde si le gardien ne dépasse pas cette limite */
+        change_position_guard(&(*guard));
+        if (collide_wall(&guard->disc, guard->dir, limit)){
+            change_direction_speed_guard(&(*guard));
+            return;
+        }
+    }
+    else change_position_guard(&(*guard));
+    
+    /* 1 chance sur 50 de changer de direction et de vitesse à chaque frame */
+    if (rand() % 50 == 1) change_direction_speed_guard(&(*guard));
+}
+
+/* Déplace les gardiens dans la salle 'room' */
+void move_guards_in_room(Room *room){
+    int i;
+    for (i = 0; i < NB_GUARDS; i++){
+        move_guard(&room->guards[i], i, room->guards, NB_GUARDS, &room->grid);
+    }
+}
+
+
+/* Déplace le joueur 'player' dans la grille 'grid' suivant la direction choisie 'pressed' */
+void move_player(Player *player, const Grid *grid, Direction pressed){
+    double limit; /* Limite de déplacement (en x ou y) */
+
+    change_direction_speed_player(&(*player), pressed);
+    if (travel_limit(player->disc, player->dir, 0, &(*grid), &limit)){
+        /* Fait en sorte que le joueur ne rentre pas en collision avec un mur */
+        change_position_player(&(*player));
+        collide_wall(&player->disc, player->dir, limit);
+        return;
+    }
+    change_position_player(&(*player));
+}
+
+/* Renvoie 1 si la touche 'key' du clavier a été pressée, 0 sinon */
+static int key_pressed(MLV_Keyboard_button key){
+    return MLV_get_keyboard_state(key) == MLV_PRESSED;
+}
+
+/* Déplace le joueur dans la salle 'room' avec les touches z, q, s, d du clavier */
+void move_player_in_room(Room *room){
+    int zqsd;
+    zqsd = 0;
+    if (key_pressed(SDLK_z)){
+        move_player(&room->player, &room->grid, UP);
+        zqsd = 1;
+    }
+    if (key_pressed(SDLK_q)){
+        move_player(&room->player, &room->grid, LEFT);
+        zqsd = 1;
+    }
+    if (key_pressed(SDLK_s)){
+        move_player(&room->player, &room->grid, DOWN);
+        zqsd = 1;
+    }
+    if (key_pressed(SDLK_d)){
+        move_player(&room->player, &room->grid, RIGHT);
+        zqsd = 1;
+    }
+    if (!zqsd) room->player.speed = INITIAL_SPEED;
+}
+
+/* Permet d'utiliser les compétences du joueur dans la salle 'room' */
+void use_player_competences_in_room(Room *room){
+    int acc, inv;
+    acc = 0;
+    inv = 0;
+    if (key_pressed(SDLK_LSHIFT)){ /* Touche shift gauche */
+        activate_acceleration(&room->player);
+        use_acceleration(&room->player);
+        acc = 1; 
+    }
+    if (key_pressed(SDLK_SPACE)){ /* Touche espace */
+        activate_invisibility(&room->player);
+        use_invisibility(&room->player);  
+        inv = 1;
+    }
+    if (!acc) desactivate_acceleration(&room->player);
+    if (!inv) desactivate_invisibility(&room->player);
 }
\ No newline at end of file
diff --git a/GameEngine.h b/GameEngine.h
index 047aa3b..708d5d9 100644
--- a/GameEngine.h
+++ b/GameEngine.h
@@ -5,6 +5,7 @@
 #include "Player.h"
 #include "Guard.h"
 #include "Terrain.h"
+#include "Collision.h"
 #define NB_GUARDS 5 /* Nombre de gardiens */
 #define NB_RELICS 3 /* Nombre de reliques */
 
@@ -16,4 +17,10 @@ typedef struct{
 
 void initialize_room(Room *room);
 
+void move_guard(Guard *guard, int index, const Guard *tab, int size, const Grid *grid);
+void move_guards_in_room(Room *room);
+void move_player(Player *player, const Grid *grid, Direction pressed);
+void move_player_in_room(Room *room);
+void use_player_competences_in_room(Room *room);
+
 #endif
\ No newline at end of file
diff --git a/Grid.c b/Grid.c
index 1e526e1..9ec561f 100644
--- a/Grid.c
+++ b/Grid.c
@@ -15,11 +15,11 @@ void initialize_grid(Grid *grid){
 }
 
 /* Affiche la grille 'grid' */
-void show_grid(Grid grid){
+void show_grid(const Grid *grid){
     int i, j;
     for (i = 0; i < NB_LIN; i++){
         for (j = 0; j < NB_COL; j++){
-            switch(grid.tab[i][j]){
+            switch(grid->tab[i][j]){
                 case WALL: printf("x"); break;
                 case RELIC: printf("r"); break;
                 case MANA: printf("-"); break;
@@ -31,21 +31,21 @@ void show_grid(Grid grid){
 }
 
 /* Renvoie 1 si la case 'coord' de la grille est vide, 0 sinon */
-int is_empty(Grid grid, Case coord){
-    return grid.tab[coord.lin][coord.col] == EMPTY;
+int is_empty(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == EMPTY;
 }
 
 /* Renvoie 1 si la case 'coord' de la grille est une case d'ouverture, 0 sinon */
-int is_gap(Grid grid, Case coord){
-    return grid.tab[coord.lin][coord.col] == GAP;
+int is_gap(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == GAP;
 }
 
 /* Renvoie 1 si la case 'coord' de la grille est une case de mur, 0 sinon */
-int is_wall(Grid grid, Case coord){
-    return grid.tab[coord.lin][coord.col] == WALL;
+int is_wall(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == WALL;
 }
 
 /* Renvoie 1 si la case 'coord' de la grille est une case de relique, 0 sinon */
-int is_relic(Grid grid, Case coord){
-    return grid.tab[coord.lin][coord.col] == RELIC;
+int is_relic(const Grid *grid, Case coord){
+    return grid->tab[coord.lin][coord.col] == RELIC;
 }
\ No newline at end of file
diff --git a/Grid.h b/Grid.h
index 1dc5c93..64f6f4a 100644
--- a/Grid.h
+++ b/Grid.h
@@ -3,7 +3,7 @@
 
 #define NB_LIN 45 /* Hauteur de la grille */
 #define NB_COL 60 /* Longueur de la grille */
-#define SIZE_CASE 14 /* Longueur des côtés d'une case */
+#define SIZE_CASE 15 /* Longueur des côtés d'une case */
 
 typedef struct{
     int lin, col;
@@ -23,10 +23,10 @@ typedef struct{
 } Grid; /* Représente la grille du jeu */
 
 void initialize_grid(Grid *grid);
-void show_grid(Grid grid);
-int is_empty(Grid grid, Case coord);
-int is_gap(Grid grid, Case coord);
-int is_wall(Grid grid, Case coord);
-int is_relic(Grid grid, Case coord);
+void show_grid(const Grid *grid);
+int is_empty(const Grid *grid, Case coord);
+int is_gap(const Grid *grid, Case coord);
+int is_wall(const Grid *grid, Case coord);
+int is_relic(const Grid *grid, Case coord);
 
 #endif
\ No newline at end of file
diff --git a/Guard.c b/Guard.c
index c53f713..e822978 100644
--- a/Guard.c
+++ b/Guard.c
@@ -8,6 +8,21 @@ void initialize_guard(Guard *guard){
     Point center = {0.0, 0.0};
     guard->disc.center = center;
     guard->disc.radius = SIZE_CASE / 2;
+    enter_normal_mode(&(*guard));
+    change_direction_speed_guard(&(*guard));
+}
+
+/* Fait entrer le gardien 'guard' en mode normal */
+void enter_normal_mode(Guard *guard){
+    guard->mode = NORMAL;
+    guard->detection_dist = DETECT_DIST_NL;
+}
+
+/* Fait entrer le gardien 'guard' en mode panique */
+void enter_panic_mode(Guard *guard){
+    guard->mode = PANIC;
+    guard->speed = SPEED_PC;
+    guard->detection_dist = DETECT_DIST_PC;
 }
 
 /* Renvoie une vitesse aléatoire entre 'min' et 'max' */
@@ -15,7 +30,18 @@ double random_speed(double min, double max){
     return rand() / (double) RAND_MAX * (max - min) + min;
 }
 
-/* Renvoie une direction aléatoire */
+/* Renvoie aléatoirement l'une des 4 directions UP, DOWN, LEFT et RIGHT */
 Direction random_direction(){
     return rand() % 4;
 }
+
+/* Change aléatoirement la direction et la vitesse du gardien 'guard' */
+void change_direction_speed_guard(Guard *guard){
+    guard->dir = random_direction();
+    if (guard->mode == NORMAL) guard->speed = random_speed(MIN_SPEED_NL, MAX_SPEED_NL);
+}
+
+/* Change la position du gardien 'guard' */
+void change_position_guard(Guard *guard){
+    change_position(&guard->disc, guard->dir, guard->speed);
+}
diff --git a/Guard.h b/Guard.h
index 62e3995..9114f90 100644
--- a/Guard.h
+++ b/Guard.h
@@ -5,7 +5,8 @@
 #include "Disc.h"
 #include "Direction.h"
 #include "Grid.h"
-#include "Player.h"
+#include "Player.h" /* Les calculs de vitesse d'un gardien sont calqués sur le joueur et ont donc besoin de "v" */
+
 #define MIN_SPEED_NL 0.3 * V /* Vitesse minimale d'un gardien en mode normal */
 #define MAX_SPEED_NL 0.8 * V /* Vitesse maximale d'un gardien en mode normal */
 #define SPEED_PC V /* Vitesse d'un gardien en mode panique */
@@ -26,11 +27,12 @@ typedef struct{
 } Guard; /* Représente un gardien */
 
 void initialize_guard(Guard *guard);
+void enter_normal_mode(Guard *guard);
+void enter_panic_mode(Guard *guard);
+
 double random_speed(double min, double max);
 Direction random_direction();
-
-void enter_normal_mode();
-void enter_panic_mode();
-void move_guard(Guard *guard);
+void change_direction_speed_guard(Guard *guard);
+void change_position_guard(Guard *guard);
 
 #endif
\ No newline at end of file
diff --git a/Main.c b/Main.c
index 4466a15..2b7cda2 100644
--- a/Main.c
+++ b/Main.c
@@ -10,26 +10,38 @@
 int main(){
     srand(time(NULL));
     Room room;
-    initialize_room(&room);
 
+    initialize_room(&room);
     MLV_create_window("Game", "Game", WINDOW_WIDTH, WINDOW_HEIGHT);
+
+    /* Boucle maîtresse gérant le jeu frame par frame 
+     (le programme doit faire 60 frames par seconde) */
     while(1){
         struct timespec end_time, new_time;
         double frametime, extratime;
-
+        /* On récupère le temps en nanoseconde au début de la frame */
         clock_gettime(CLOCK_REALTIME, &end_time);
+
+        /* Affichage de la frame courante */
         draw_room(&room);
+        move_guards_in_room(&room);
+        move_player_in_room(&room);
+        use_player_competences_in_room(&room);
+
 
+        /* On récupère le temps en nanoseconde à la fin de la frame */
         clock_gettime(CLOCK_REALTIME, &new_time);
+
+        /* Calcule du temps passé entre le début et la fin de la frame */
         frametime = new_time.tv_sec - end_time.tv_sec;
         frametime += (new_time.tv_sec - end_time.tv_sec) / 1.0E9;
 
+        /* On force le programme à passer au moins 1/60 seconde au total */
         extratime = 1.0 / 60 - frametime;
         if (extratime > 0){
             MLV_wait_milliseconds((int) (extratime * 1000));
         }
     }
-
     MLV_wait_seconds(100);
     MLV_free_window();
     return 0;
diff --git a/Player.c b/Player.c
index ab8d46d..5a48da7 100644
--- a/Player.c
+++ b/Player.c
@@ -12,5 +12,76 @@ void initialize_player(Player *player){
     player->max_speed = MAX_SPEED;
     player->mana = 0;
     player->max_mana = MAX_MANA;
-    player->comp = NONE;
-}
\ No newline at end of file
+    player->comp.acceleration = UNUSED;
+    player->comp.invisibility = UNUSED;
+}
+
+/* Change la position de l'agent 'agent' suivant sa direction 'dir' et sa vitesse 'speed' */
+void change_position(Disc *agent, Direction dir, double speed){
+    double offset_x[] = {0, 0, -speed, speed};
+    double offset_y[] = {-speed, speed, 0, 0};
+    agent->center.x += offset_x[dir];
+    agent->center.y += offset_y[dir];    
+}
+
+/* Change la position du joueur 'player' */
+void change_position_player(Player *player){
+    change_position(&player->disc, player->dir, player->speed);
+}
+
+/* Renvoie 1 si les directions 'd1' et 'd2' sont les mêmes, 0 sinon.
+ * Les directions latérales sont uniquement comparées entre elles et pour les directions horizontales également
+ * (donc Haut est seulement comparée à Bas et vice versa et Gauche seulement à Droite et vice versa)
+*/
+int same_direction(Direction d1, Direction d2){
+    if ((d1 == UP && d2 == DOWN) || (d1 == DOWN && d2 == UP)) return 0;
+    if ((d1 == LEFT && d2 == RIGHT) || (d1 == RIGHT && d2 == LEFT)) return 0;
+    return 1;
+}
+
+/* Change la direction et la vitesse du joueur 'player' suivant la direction choisie 'pressed' */
+void change_direction_speed_player(Player *player, Direction pressed){
+    if (same_direction(pressed, player->dir)){
+        player->speed += ACC;
+        if (player->speed > player->max_speed) player->speed = player->max_speed;
+    }
+    /* Quand on change de direction, la vitesse est réinitialisée */
+    else player->speed = INITIAL_SPEED;
+    player->dir = pressed;
+}
+
+/* Active la compétence Accélération du joueur 'player' */
+void activate_acceleration(Player *player){
+    if (player->mana >= ACC_MANA && player->comp.acceleration == UNUSED){
+        player->comp.acceleration = USED;
+        player->max_speed = MAX_SPEED_ACC;
+    }    
+}
+
+/* Désactive la compétence Accélération du joueur 'player' */
+void desactivate_acceleration(Player *player){
+    player->comp.acceleration = UNUSED;
+    player->max_speed = MAX_SPEED;
+}
+
+/* Fait utiliser la compétence Accélération du joueur 'player' donc du mana est consommé */
+void use_acceleration(Player *player){
+    if (player->comp.acceleration == USED && player->mana >= ACC_MANA) player->mana -= ACC_MANA;
+    else desactivate_acceleration(&(*player));
+}
+
+/* Active la compétence Invisibilité du joueur 'player' */
+void activate_invisibility(Player *player){
+    if (player->mana >= INV_MANA && player->comp.invisibility == UNUSED) player->comp.invisibility = USED; 
+}
+
+/* Désactive la compétence Invisibilité du joueur 'player' */
+void desactivate_invisibility(Player *player){
+    player->comp.invisibility = UNUSED;
+}
+
+/* Fait utiliser la compétence Invisibilité du joueur 'player' donc du mana est consommé */
+void use_invisibility(Player *player){
+    if (player->comp.invisibility == USED && player->mana >= INV_MANA) player->mana -= INV_MANA;
+    else desactivate_invisibility(&(*player));
+}
diff --git a/Player.h b/Player.h
index f42744e..6844f95 100644
--- a/Player.h
+++ b/Player.h
@@ -5,17 +5,21 @@
 #include "Disc.h"
 #include "Direction.h"
 #include "Grid.h"
-#define V 10 /* Vitesse "v" sur laquelle les calculs de vitesse du joueur sont basés */
+
+#define V 3.0 /* Vitesse "v" sur laquelle les calculs de vitesse du joueur sont basés */
 #define INITIAL_SPEED 0.1 * V /* Vitesse initiale quand le joueur démarre ou change de direction */
-#define ACC 0.03 * V /* On accélère INITIAL_SPEED par ACC à chaque frame */
+#define ACC 0.03 * V /* On accélère INITIAL_SPEED par ACC à chaque frame où la touche de direction reste enfoncée */
 #define MAX_SPEED 0.9 * V /* Vitesse maximale atteignable par le joueur */
-#define MAX_SPEED_ACC 1.2 * V /* Vitesse maximale atteignable avec la compétence ACCELERATION */
+#define MAX_SPEED_ACC 1.2 * V /* Vitesse maximale atteignable avec la compétence Accélération */
 #define MAX_MANA 100 /* Quantité maximale de mana absorbable */
+#define INV_MANA 1 /* Quantité de mana consommée par la compétence Invisibilité à chaque frame */
+#define ACC_MANA 2 /* Quantité de mana consommée par la compétence Accélération à chaque frame */
+#define USED 1
+#define UNUSED 0
 
-typedef enum{
-    NONE, /* Aucune compétence activée */
-    ACCELERATION, /* Accélération surchargée */
-    INVISIBILITY /* Invisibilité */
+typedef struct{
+    int acceleration; /* Accélération */
+    int invisibility; /* Invisibilité */
 } Competence; /* Compétences magiques du joueur */
 
 typedef struct{
@@ -23,9 +27,20 @@ typedef struct{
     Direction dir; /* Sa direction */
     double speed, max_speed; /* Sa vitesse et la vitesse maximale atteignable */
     int mana, max_mana; /* Sa réverse de mana et la quantité maximale de mana absorbable */
-    Competence comp; /* La compétence activée ou non */
+    Competence comp; /* Ses compétences */
 } Player; /* Représente le joueur */
 
 void initialize_player(Player *player);
+void change_position(Disc *agent, Direction dir, double speed);
+void change_position_player(Player *player);
+int same_direction(Direction d1, Direction d2);
+void change_direction_speed_player(Player *player, Direction pressed);
+
+void activate_acceleration(Player *player);
+void desactivate_acceleration(Player *player);
+void use_acceleration(Player *player);
+void activate_invisibility(Player *player);
+void desactivate_invisibility(Player *player);
+void use_invisibility(Player *player);
 
 #endif
\ No newline at end of file
diff --git a/Terrain.c b/Terrain.c
index 311333a..4974132 100644
--- a/Terrain.c
+++ b/Terrain.c
@@ -96,7 +96,7 @@ Case point_case(Point point){
     return _case;
 }
 
-/* Redimensionne les coordonnées du point 'point' pour l'adapter aux dimensions réelles du terrain */
+/* Redimensionne les coordonnées du point 'point' pour l'adapter aux dimensions "réelles" du terrain */
 void resize_point(Point *point){
     point->x *= SIZE_CASE;
     point->y *= SIZE_CASE;
@@ -116,7 +116,7 @@ void place_relics_in_grid(int nb_relics, Grid *grid, const Player *player){
             resize_point(&point);
             if (far_enough_from_the_player(point, &(*player))){
                 coord = point_case(point);
-                if (is_empty(*grid, coord)){
+                if (is_empty(&(*grid), coord)){
                     grid->tab[coord.lin][coord.col] = RELIC;
                     valid = 1;
                 }
@@ -131,7 +131,7 @@ void place_manas_in_grid(Grid *grid){
     for (i = 0; i < NB_LIN; i++){
         for (j = 0; j < NB_COL; j++){
             Case coord = {i, j};
-            if (is_empty(*grid, coord) || is_gap(*grid, coord)) grid->tab[i][j] = MANA;
+            if (is_empty(&(*grid), coord) || is_gap(&(*grid), coord)) grid->tab[i][j] = MANA;
         }
     }
 }
@@ -151,7 +151,7 @@ int superposition_between_guards(const Guard *guard, int index, const Guard *tab
 /* Renvoie 1 si le gardien 'guard' rentre dans un mur 
  * possiblement situé sur l'une des 4 cases diagonales adjacentes à la sienne, 0 sinon 
 */
-int in_diagonal_wall(const Guard *guard, Grid grid){
+int in_diagonal_wall(const Guard *guard, const Grid *grid){
     int i, j;
     Case c_guard; /* Case contenant le centre du disque du gardien */
     c_guard = point_case(guard->disc.center);
@@ -162,7 +162,7 @@ int in_diagonal_wall(const Guard *guard, Grid grid){
                 /* On ne veut que les cases situées sur les diagonales */
                 Case diagonal = {c_guard.lin + i, c_guard.col + j};
 
-                if (is_wall(grid, diagonal)){
+                if (is_wall(&(*grid), diagonal)){
                     /* On veut le coin de case qui est commun à la case 'c_guard' et 'diagonal' */
                     if (i == -1) diagonal.lin += 1;
                     if (j == -1) diagonal.col += 1;
@@ -181,16 +181,17 @@ int in_diagonal_wall(const Guard *guard, Grid grid){
 /* Renvoie 1 si le gardien 'guard' rentre dans un mur ou une ouverture
  * possiblement situé sur l'une des 4 cases latérales adjacentes à la sienne, 0 sinon 
 */
-int in_lateral_wall_or_gap(const Guard *guard, Grid grid){
+int in_lateral_wall_or_gap(const Guard *guard, const Grid *grid){
     int i, j;
     Case c_guard; /* Case contenant le centre du disque du gardien */
-    Point middle;
+    Point middle; /* Point du milieu commun à la case 'c_guard' 
+                   et la case ('up_down' ou 'left_right') dont on cherche à savoir si c'est un mur ou une ouverture */
     c_guard = point_case(guard->disc.center);
     
     /* Case en haut et en bas */
     for (i = -1; i < 2; i++){
         Case up_down = {c_guard.lin + i, c_guard.col};
-        if (i != 0 && (is_wall(grid, up_down) || is_gap(grid, up_down))){
+        if (i != 0 && (is_wall(&(*grid), up_down) || is_gap(&(*grid), up_down))){
             middle.x = up_down.col + (1 / (double) 2);
 
             if (i == -1) middle.y = up_down.lin + 1;
@@ -203,7 +204,7 @@ int in_lateral_wall_or_gap(const Guard *guard, Grid grid){
     /* Case à gauche et à droite */
     for (j = -1; j < 2; j++){
         Case left_right = {c_guard.lin, c_guard.col + j};
-        if (j != 0 && (is_wall(grid, left_right) || is_gap(grid, left_right))){
+        if (j != 0 && (is_wall(&(*grid), left_right) || is_gap(&(*grid), left_right))){
             middle.y = left_right.lin + (1 / (double) 2);
 
             if (j == -1) middle.x = left_right.col + 1;
@@ -220,7 +221,7 @@ int in_lateral_wall_or_gap(const Guard *guard, Grid grid){
  * et en prenant en compte les autres gardiens dans 'tab' de taille 'size'.
  * 'index' est l'indice du gardien 'guard' dans le tableau 'tab'.
 */
-void place_guard_in_grid(Guard *guard, int index, const Guard *tab, int size, Grid grid, const Player *player){
+void place_guard_in_grid(Guard *guard, int index, const Guard *tab, int size, const Grid *grid, const Player *player){
     int valid;
     Case coord;
     Point point;
@@ -232,13 +233,13 @@ void place_guard_in_grid(Guard *guard, int index, const Guard *tab, int size, Gr
         if (far_enough_from_the_player(point, &(*player))){
 
             coord = point_case(point);
-            if (!is_wall(grid, coord) && !is_gap(grid, coord)){
+            if (!is_wall(&(*grid), coord) && !is_gap(&(*grid), coord)){
 
                 guard->disc.center.x = point.x;
                 guard->disc.center.y = point.y;
                 if (!superposition_between_guards(&(*guard), index, tab, size)){
-                    if (!in_diagonal_wall(&(*guard), grid)){
-                        if (!in_lateral_wall_or_gap(&(*guard), grid)) valid = 1;
+                    if (!in_diagonal_wall(&(*guard), &(*grid))){
+                        if (!in_lateral_wall_or_gap(&(*guard), &(*grid))) valid = 1;
                     }
                 }
             }
diff --git a/Terrain.h b/Terrain.h
index f1c5ea7..e050de9 100644
--- a/Terrain.h
+++ b/Terrain.h
@@ -6,6 +6,7 @@
 #include "Disc.h"
 #include "Player.h"
 #include "Guard.h"
+
 #define MINSIDE 9 /* Longueur minimale des côtés des compartiments crées */
 #define LENGTH_GAP 3 /* Taille d'une ouverture : 3 cases */
 #define INITIAL_POS_X 2.0 * SIZE_CASE /* Coordonnée x de la position initiale du joueur */
@@ -30,8 +31,8 @@ void place_relics_in_grid(int nb_relics, Grid *grid, const Player *player);
 void place_manas_in_grid(Grid *grid);
 
 int superposition_between_guards(const Guard *guard, int index, const Guard *tab, int size);
-int in_diagonal_wall(const Guard *guard, Grid grid);
-int in_lateral_wall_or_gap(const Guard *guard, Grid grid);
-void place_guard_in_grid(Guard *guard, int index, const Guard *tab, int size, Grid grid, const Player *player);
+int in_diagonal_wall(const Guard *guard, const Grid *grid);
+int in_lateral_wall_or_gap(const Guard *guard, const Grid *grid);
+void place_guard_in_grid(Guard *guard, int index, const Guard *tab, int size, const Grid *grid, const Player *player);
 
 #endif
\ No newline at end of file
diff --git a/makefile b/makefile
index cadbaae..f4c361d 100644
--- a/makefile
+++ b/makefile
@@ -3,10 +3,10 @@ CC=gcc
 CFLAGS=-ansi -Wall
 LDFLAGS=-lm -lMLV
 EXEC=exec
-OBJ=Main.o Direction.o Point.o Disc.o Player.o Guard.o Grid.o Terrain.o GameEngine.o Graphic.o
+OBJ=Main.o Direction.o Point.o Disc.o Player.o Guard.o Grid.o Terrain.o Collision.o GameEngine.o Graphic.o
 
 $(EXEC): $(OBJ)
-	$(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)
+	$(CC) -g -o $@ $^ $(CFLAGS) $(LDFLAGS)
 
 Main.o: Main.c GameEngine.h Graphic.h
 
@@ -24,7 +24,9 @@ Grid.o: Grid.c Grid.h
 
 Terrain.o: Terrain.c Terrain.h Grid.h Point.h Disc.h Player.h Guard.h
 
-GameEngine.o: GameEngine.c GameEngine.h Grid.h Player.h Guard.h Terrain.h
+Collision.o: Collision.c Collision.h Point.h Disc.h Direction.h Grid.h Terrain.h Guard.h
+
+GameEngine.o: GameEngine.c GameEngine.h Grid.h Player.h Guard.h Terrain.h Collision.h
 
 Graphic.o: Graphic.c Graphic.h GameEngine.h
 

commit a45b091960cbaebb37c1013cffb6da5a53f4fb1d
Author: padawan <padawan@DebianUPEM2019.padawan>
Date:   Sun Jan 8 20:28:18 2023 +0100

    make + interface graphic + main

diff --git a/Graphic.c b/Graphic.c
new file mode 100644
index 0000000..d599524
--- /dev/null
+++ b/Graphic.c
@@ -0,0 +1,55 @@
+#include "Graphic.h"
+#include <stdio.h>
+
+
+/* Dessine la grille 'grid' */
+void draw_grid(const Grid *grid){
+    int i, j;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            MLV_draw_filled_rectangle(j * SIZE_CASE, i * SIZE_CASE, SIZE_CASE, SIZE_CASE, MLV_COLOR_GRAY);
+            MLV_draw_rectangle(j * SIZE_CASE, i * SIZE_CASE, SIZE_CASE, SIZE_CASE, MLV_COLOR_GRAY50);
+            
+            switch(grid->tab[i][j]){
+                case WALL:
+                    MLV_draw_filled_rectangle(j * SIZE_CASE, i * SIZE_CASE, SIZE_CASE, SIZE_CASE, MLV_COLOR_BLACK);
+                    break;
+                case RELIC: 
+                    MLV_draw_filled_rectangle(j * SIZE_CASE, i * SIZE_CASE, SIZE_CASE, SIZE_CASE, MLV_COLOR_YELLOW1);
+                    break;
+                case MANA:
+                    MLV_draw_filled_circle(j * SIZE_CASE + SIZE_CASE / 2, i * SIZE_CASE + SIZE_CASE / 2, SIZE_CASE / 3, MLV_COLOR_SKY_BLUE);
+                    MLV_draw_circle(j * SIZE_CASE + SIZE_CASE / 2, i * SIZE_CASE + SIZE_CASE / 2, SIZE_CASE / 3, MLV_COLOR_SKY_BLUE);
+                    break;
+                default: ;
+            }
+        }
+    }
+}
+
+/* Dessine le disque 'disc' avec la couleur 'color' */
+void draw_disc(Disc disc, MLV_Color color){
+    MLV_draw_filled_circle(disc.center.x, disc.center.y, disc.radius, color);
+    MLV_draw_circle(disc.center.x, disc.center.y, disc.radius, MLV_COLOR_GRAY50);
+}
+
+/* Dessine le joueur 'player' */
+void draw_player(const Player *player){
+    draw_disc(player->disc, MLV_COLOR_RED);
+}
+
+/* Dessine le gardien 'guard' */
+void draw_guard(const Guard *guard){
+    draw_disc(guard->disc, MLV_COLOR_BLUE);
+}
+
+/* Dessine la salle du jeu 'room' */
+void draw_room(const Room *room){
+    int i;
+    draw_grid(&room->grid);
+    draw_player(&room->player);
+    for (i = 0; i < NB_GUARDS; i++){
+        draw_guard(&room->guards[i]);
+    }
+    MLV_actualise_window();
+}
\ No newline at end of file
diff --git a/Graphic.h b/Graphic.h
new file mode 100644
index 0000000..8967125
--- /dev/null
+++ b/Graphic.h
@@ -0,0 +1,15 @@
+#ifndef __GRAPHIC__
+#define __GRAPHIC__
+
+#include "GameEngine.h"
+#include <MLV/MLV_all.h>
+#define WINDOW_WIDTH NB_COL * SIZE_CASE /* Largeur de la fenêtre */
+#define WINDOW_HEIGHT NB_LIN * SIZE_CASE /* Hauteur de la fenêtre */
+
+void draw_grid(const Grid *grid);
+void draw_disc(Disc disc, MLV_Color color);
+void draw_player(const Player *player);
+void draw_guard(const Guard *guard);
+void draw_room(const Room *room);
+
+#endif
\ No newline at end of file
diff --git a/Main.c b/Main.c
new file mode 100644
index 0000000..4466a15
--- /dev/null
+++ b/Main.c
@@ -0,0 +1,36 @@
+#define _POSIX_C_SOURCE 199309L
+#include "GameEngine.h"
+#include "Graphic.h"
+#include <MLV/MLV_all.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+
+int main(){
+    srand(time(NULL));
+    Room room;
+    initialize_room(&room);
+
+    MLV_create_window("Game", "Game", WINDOW_WIDTH, WINDOW_HEIGHT);
+    while(1){
+        struct timespec end_time, new_time;
+        double frametime, extratime;
+
+        clock_gettime(CLOCK_REALTIME, &end_time);
+        draw_room(&room);
+
+        clock_gettime(CLOCK_REALTIME, &new_time);
+        frametime = new_time.tv_sec - end_time.tv_sec;
+        frametime += (new_time.tv_sec - end_time.tv_sec) / 1.0E9;
+
+        extratime = 1.0 / 60 - frametime;
+        if (extratime > 0){
+            MLV_wait_milliseconds((int) (extratime * 1000));
+        }
+    }
+
+    MLV_wait_seconds(100);
+    MLV_free_window();
+    return 0;
+}
\ No newline at end of file
diff --git a/makefile b/makefile
new file mode 100644
index 0000000..cadbaae
--- /dev/null
+++ b/makefile
@@ -0,0 +1,35 @@
+
+CC=gcc
+CFLAGS=-ansi -Wall
+LDFLAGS=-lm -lMLV
+EXEC=exec
+OBJ=Main.o Direction.o Point.o Disc.o Player.o Guard.o Grid.o Terrain.o GameEngine.o Graphic.o
+
+$(EXEC): $(OBJ)
+	$(CC) -o $@ $^ $(CFLAGS) $(LDFLAGS)
+
+Main.o: Main.c GameEngine.h Graphic.h
+
+Direction.o: Direction.c Direction.h
+
+Point.o: Point.c Point.h
+
+Disc.o: Disc.c Disc.h Point.h
+
+Player.o: Player.c Player.h Point.h Disc.h Direction.h Grid.h
+
+Guard.o: Guard.c Guard.h Point.h Disc.h Direction.h Grid.h Player.h
+
+Grid.o: Grid.c Grid.h
+
+Terrain.o: Terrain.c Terrain.h Grid.h Point.h Disc.h Player.h Guard.h
+
+GameEngine.o: GameEngine.c GameEngine.h Grid.h Player.h Guard.h Terrain.h
+
+Graphic.o: Graphic.c Graphic.h GameEngine.h
+
+%.o: %.c
+	$(CC) -c $< $(CFLAGS) $(LDFLAGS)
+
+clean:
+	rm -f *.o $(EXEC)
\ No newline at end of file

commit 1845d172f76afb0559f09ad7447150bbce17fdfd
Author: Sylvain Tran <sylvain.tran@etud.u-pem.fr>
Date:   Fri Jan 6 19:15:57 2023 +0100

    Création du module GameEngine : moteur du jeu; Placement des gardiens dans la grille; Initialisation de la salle du jeu

diff --git a/Direction.c b/Direction.c
new file mode 100644
index 0000000..bfd4e52
--- /dev/null
+++ b/Direction.c
@@ -0,0 +1 @@
+#include "Direction.h"
\ No newline at end of file
diff --git a/GameEngine.c b/GameEngine.c
new file mode 100644
index 0000000..ef44f6b
--- /dev/null
+++ b/GameEngine.c
@@ -0,0 +1,25 @@
+#include "GameEngine.h"
+#include <stdio.h>
+
+
+/* Initialise la salle 'room' */
+void initialize_room(Room *room){
+    int i;
+    /* Grille */
+    initialize_grid(&room->grid);
+    generate_compartments(&room->grid, NB_COL - 2, 1, NB_COL - 2, NB_LIN - 2, 1, NB_LIN - 2);
+
+    /* Joueur */
+    initialize_player(&room->player);
+    place_player_in_grid(&room->player);
+
+    /* Reliques + Manas */
+    place_relics_in_grid(NB_RELICS, &room->grid, &room->player);
+    place_manas_in_grid(&room->grid);
+
+    /* Gardiens */
+    for (i = 0; i < NB_GUARDS; i++){
+        initialize_guard(&room->guards[i]);
+        place_guard_in_grid(&room->guards[i], i, room->guards, NB_GUARDS, room->grid, &room->player);
+    }
+}
\ No newline at end of file
diff --git a/GameEngine.h b/GameEngine.h
new file mode 100644
index 0000000..047aa3b
--- /dev/null
+++ b/GameEngine.h
@@ -0,0 +1,19 @@
+#ifndef __GAMEENGINE__
+#define __GAMEENGINE__
+
+#include "Grid.h"
+#include "Player.h"
+#include "Guard.h"
+#include "Terrain.h"
+#define NB_GUARDS 5 /* Nombre de gardiens */
+#define NB_RELICS 3 /* Nombre de reliques */
+
+typedef struct{
+    Grid grid;
+    Player player;
+    Guard guards[NB_GUARDS];
+} Room; /* Représente la salle du jeu rassemblant tous les objets du jeu */
+
+void initialize_room(Room *room);
+
+#endif
\ No newline at end of file
diff --git a/Grid.c b/Grid.c
index 5949834..1e526e1 100644
--- a/Grid.c
+++ b/Grid.c
@@ -2,6 +2,39 @@
 #include <stdio.h>
 
 
+/* Initialise la grille 'grid' */
+void initialize_grid(Grid *grid){
+    int i, j;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            /* Création des 4 murs extérieurs */
+            if (i == 0 || i == NB_LIN - 1 || j == 0 || j == NB_COL - 1) grid->tab[i][j] = WALL;
+            else grid->tab[i][j] = EMPTY;
+        }
+    }
+}
+
+/* Affiche la grille 'grid' */
+void show_grid(Grid grid){
+    int i, j;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            switch(grid.tab[i][j]){
+                case WALL: printf("x"); break;
+                case RELIC: printf("r"); break;
+                case MANA: printf("-"); break;
+                default: printf(" ");
+            }
+        }
+        printf("\n");
+    }
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est vide, 0 sinon */
+int is_empty(Grid grid, Case coord){
+    return grid.tab[coord.lin][coord.col] == EMPTY;
+}
+
 /* Renvoie 1 si la case 'coord' de la grille est une case d'ouverture, 0 sinon */
 int is_gap(Grid grid, Case coord){
     return grid.tab[coord.lin][coord.col] == GAP;
diff --git a/Grid.h b/Grid.h
index b063d35..1dc5c93 100644
--- a/Grid.h
+++ b/Grid.h
@@ -3,7 +3,7 @@
 
 #define NB_LIN 45 /* Hauteur de la grille */
 #define NB_COL 60 /* Longueur de la grille */
-#define SIZE_CASE 10 /* Longueur des côtés d'une case */
+#define SIZE_CASE 14 /* Longueur des côtés d'une case */
 
 typedef struct{
     int lin, col;
@@ -15,13 +15,16 @@ typedef enum{
     GAP, /* Ouverture */
     MANA, /* Traces de mana */
     RELIC, /* Relique */
-    TAKE_RELIC /* Relique prise */
+    RELIC_TAKEN /* Relique prise */
 } InfoCase; /* Donne une information sur une case */
 
 typedef struct{
     InfoCase tab[NB_LIN][NB_COL];
 } Grid; /* Représente la grille du jeu */
 
+void initialize_grid(Grid *grid);
+void show_grid(Grid grid);
+int is_empty(Grid grid, Case coord);
 int is_gap(Grid grid, Case coord);
 int is_wall(Grid grid, Case coord);
 int is_relic(Grid grid, Case coord);
diff --git a/Guard.c b/Guard.c
new file mode 100644
index 0000000..c53f713
--- /dev/null
+++ b/Guard.c
@@ -0,0 +1,21 @@
+#include "Guard.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+
+/* Initialise le gardien 'guard' */
+void initialize_guard(Guard *guard){
+    Point center = {0.0, 0.0};
+    guard->disc.center = center;
+    guard->disc.radius = SIZE_CASE / 2;
+}
+
+/* Renvoie une vitesse aléatoire entre 'min' et 'max' */
+double random_speed(double min, double max){
+    return rand() / (double) RAND_MAX * (max - min) + min;
+}
+
+/* Renvoie une direction aléatoire */
+Direction random_direction(){
+    return rand() % 4;
+}
diff --git a/Guard.h b/Guard.h
index 5f74b62..62e3995 100644
--- a/Guard.h
+++ b/Guard.h
@@ -4,18 +4,33 @@
 #include "Point.h"
 #include "Disc.h"
 #include "Direction.h"
+#include "Grid.h"
+#include "Player.h"
+#define MIN_SPEED_NL 0.3 * V /* Vitesse minimale d'un gardien en mode normal */
+#define MAX_SPEED_NL 0.8 * V /* Vitesse maximale d'un gardien en mode normal */
+#define SPEED_PC V /* Vitesse d'un gardien en mode panique */
+#define DETECT_DIST_NL 4 /* Distance de détection d'un gardien en mode normal */
+#define DETECT_DIST_PC 6 /* Distance de détection d'un gardien en mode panique */
 
 typedef enum{
-    NORMAL,
-    PANIC
-} Mode;
+    NORMAL, /* Mode normal */
+    PANIC /* Mode panique */
+} Mode; /* Mode du gardien */
 
 typedef struct{
-    Disc disc;
-    Mode mode;
-    Direction dir;
-    double speed;
-    int dist_detection;
-} Guard;
+    Disc disc; /* Représentation du gardien par un disque */
+    Mode mode; /* Le mode activé */
+    Direction dir; /* Sa direction */
+    double speed; /* Sa vitesse */
+    int detection_dist; /* Distance de détection en nombre de cases */
+} Guard; /* Représente un gardien */
+
+void initialize_guard(Guard *guard);
+double random_speed(double min, double max);
+Direction random_direction();
+
+void enter_normal_mode();
+void enter_panic_mode();
+void move_guard(Guard *guard);
 
 #endif
\ No newline at end of file
diff --git a/Player.c b/Player.c
new file mode 100644
index 0000000..ab8d46d
--- /dev/null
+++ b/Player.c
@@ -0,0 +1,16 @@
+#include "Player.h"
+#include <stdio.h>
+
+
+/* Initialise le joueur 'player' */
+void initialize_player(Player *player){
+    Point center = {0.0, 0.0};
+    player->disc.center = center;
+    player->disc.radius = SIZE_CASE / 2;
+    player->dir = RIGHT;
+    player->speed = INITIAL_SPEED;
+    player->max_speed = MAX_SPEED;
+    player->mana = 0;
+    player->max_mana = MAX_MANA;
+    player->comp = NONE;
+}
\ No newline at end of file
diff --git a/Player.h b/Player.h
index 30dc793..f42744e 100644
--- a/Player.h
+++ b/Player.h
@@ -4,20 +4,27 @@
 #include "Point.h"
 #include "Disc.h"
 #include "Direction.h"
+#include "Grid.h"
+#define V 10 /* Vitesse "v" sur laquelle les calculs de vitesse du joueur sont basés */
+#define INITIAL_SPEED 0.1 * V /* Vitesse initiale quand le joueur démarre ou change de direction */
+#define ACC 0.03 * V /* On accélère INITIAL_SPEED par ACC à chaque frame */
+#define MAX_SPEED 0.9 * V /* Vitesse maximale atteignable par le joueur */
+#define MAX_SPEED_ACC 1.2 * V /* Vitesse maximale atteignable avec la compétence ACCELERATION */
+#define MAX_MANA 100 /* Quantité maximale de mana absorbable */
 
 typedef enum{
-    NONE,
-    ACCELERATION,
-    INVISIBILITY
-} Competence;
+    NONE, /* Aucune compétence activée */
+    ACCELERATION, /* Accélération surchargée */
+    INVISIBILITY /* Invisibilité */
+} Competence; /* Compétences magiques du joueur */
 
 typedef struct{
-    Disc disc;
-    Direction dir;
-    double speed, speed_max;
-    int mana;
-    Competence comp;
-} Player;
+    Disc disc; /* Représentation du joueur par un disque */
+    Direction dir; /* Sa direction */
+    double speed, max_speed; /* Sa vitesse et la vitesse maximale atteignable */
+    int mana, max_mana; /* Sa réverse de mana et la quantité maximale de mana absorbable */
+    Competence comp; /* La compétence activée ou non */
+} Player; /* Représente le joueur */
 
 void initialize_player(Player *player);
 
diff --git a/Point.c b/Point.c
index 4edd317..25deea7 100644
--- a/Point.c
+++ b/Point.c
@@ -13,6 +13,11 @@ double distance(Point a, Point b){
     return sqrt(SQUARE(dx) + SQUARE(dy));
 }
 
+/* Renvoie un entier aléatoire entre les entiers 'a' et 'b' (tous deux compris) */
+int random_int(int a, int b){
+    return rand() % (b - a + 1) + a;
+}
+
 /* Renvoie un double aléatoire entre les entiers 'a' et 'b' (tous deux compris) */
 double random_double(int a, int b){
     int n, nb_decimal;
@@ -20,13 +25,13 @@ double random_double(int a, int b){
     n = pow(10, nb_decimal);
     a *= n;
     b *= n;
-    return (rand() % (b - a + 1) + a) / (double) n;
+    return (random_int(a, b)) / (double) n;
 }
 
 /* Renvoie un point aléatoire.
- * La coordonnée x (resp. y) du point est entre 'x1' et 'x2 (resp. 'y1' et 'y2').
+ * La coordonnée x (resp. y) du point est entre 'x1' et 'x2' (resp. 'y1' et 'y2').
 */
-Point ramdom_point(int x1, int x2, int y1, int y2){
+Point random_point(int x1, int x2, int y1, int y2){
     Point point = {random_double(x1, x2), random_double(y1, y2)};
     return point;
 }
\ No newline at end of file
diff --git a/Point.h b/Point.h
index 5aa4070..07fc3f6 100644
--- a/Point.h
+++ b/Point.h
@@ -6,7 +6,8 @@ typedef struct{
 } Point; /* Représente un point de coordonnées (x, y) */
 
 double distance(Point a, Point b);
+int random_int(int a, int b);
 double random_double(int a, int b);
-Point ramdom_point(int x1, int x2, int y1, int y2);
+Point random_point(int x1, int x2, int y1, int y2);
 
 #endif
\ No newline at end of file
diff --git a/Terrain.c b/Terrain.c
index dc08b2e..311333a 100644
--- a/Terrain.c
+++ b/Terrain.c
@@ -3,30 +3,6 @@
 #include <stdlib.h>
 
 
-/* Initialise la grille */
-void initialize_grid(Grid *grid){
-    int i, j;
-    for (i = 0; i < NB_LIN; i++){
-        for (j = 0; j < NB_COL; j++){
-            /* Création des 4 murs extérieurs */
-            if (i == 0 || i == NB_LIN - 1 || j == 0 || j == NB_COL - 1) grid->tab[i][j] = WALL;
-            else grid->tab[i][j] = EMPTY;
-        }
-    }
-}
-
-/* Affiche la grille */
-void show_grid(Grid grid){
-    int i, j;
-    for (i = 0; i < NB_LIN; i++){
-        for (j = 0; j < NB_COL; j++){
-            if (grid.tab[i][j] == WALL) printf("x");
-            else printf(" ");
-        }
-        printf("\n");
-    }
-}
-
 /* Génère un mur vertical dans la grille 'grid' de la ligne 'start_y' à la ligne 'end_y' à la colonne n°'column' */
 void generate_vertical_wall(Grid *grid, int column, int start_y, int end_y){
     int i, alea;
@@ -43,7 +19,7 @@ void generate_vertical_wall(Grid *grid, int column, int start_y, int end_y){
 void generate_horizontal_wall(Grid *grid, int line, int start_x, int end_x){
     int i, alea;
 
-    alea = rand() % 2;
+    alea = rand() % 2; /* Permet de savoir à quelle extrémité du mur les cases d'ouvertures doivent être placées */
     for (i = start_x; i <= end_x; i++){
         grid->tab[line][i] = WALL;
         if (alea == 0 && i < start_x + LENGTH_GAP) grid->tab[line][i] = GAP;
@@ -51,11 +27,6 @@ void generate_horizontal_wall(Grid *grid, int line, int start_x, int end_x){
     }
 }
 
-/* Renvoie un entier aléatoire entre les entiers 'a' et 'b' (tous deux compris) */
-int random_int(int a, int b){
-    return rand() % (b - a + 1) + a;
-}
-
 /* Cherche aléatoirement un numéro de ligne ou colonne entre 'start' et 'end' pour savoir où placer un mur de façon 
  * à ce que la taille (en longueur ou largeur) des deux compartiments crées à gauche et à droite soit plus grande que MINSIDE.
  * On récupère via 'pos' la position de la ligne ou colonne où le mur sera généré.
@@ -102,16 +73,16 @@ void generate_compartments(Grid *grid, int x, int start_x, int end_x, int y, int
 }
 
 
-/* Place le joueur dans la grille */
+/* Place le joueur 'player' dans la grille */
 void place_player_in_grid(Player *player){
     player->disc.center.x = INITIAL_POS_X;
     player->disc.center.y = INITIAL_POS_Y;
 }
 
 
-/* Renvoie 1 si le point 'point' est à une distance d'au moins MIN_DIST de la position du joueur 'player', 0 sinon */
-int far_enough_from_the_player(Point point, Player player){
-    return distance(point, player.disc.center) >= MIN_DIST;
+/* Renvoie 1 si le point 'point' est à une distance d'au moins MINDIST de la position du joueur 'player', 0 sinon */
+int far_enough_from_the_player(Point point, const Player *player){
+    return distance(point, player->disc.center) >= MINDIST;
 }
 
 /* Renvoie la partie entière de 'd' */
@@ -121,23 +92,34 @@ int integer(double d){
 
 /* Renvoie la case contenant le point 'point' */
 Case point_case(Point point){
-    Case _case = {integer(point.y), integer(point.x)};
+    Case _case = {integer(point.y / SIZE_CASE), integer(point.x / SIZE_CASE)};
     return _case;
 }
 
-/* Place 'nb_relics' reliques dans la grille 'grid' */
-void place_relics_in_grid(int nb_relics, Grid *grid, Player player){
-    int i;
+/* Redimensionne les coordonnées du point 'point' pour l'adapter aux dimensions réelles du terrain */
+void resize_point(Point *point){
+    point->x *= SIZE_CASE;
+    point->y *= SIZE_CASE;
+}
+
+
+/* Place 'nb_relics' reliques dans la grille 'grid' assez loin du joueur 'player' */
+void place_relics_in_grid(int nb_relics, Grid *grid, const Player *player){
+    int i, valid;
     Case coord;
     Point point;
 
     for (i = 0; i < nb_relics; i++){
-        point = ramdom_point(1, NB_COL - 2, 1, NB_COL - 2);
-
-        if (far_enough_from_the_player(point, player)){
-            coord = point_case(point);
-            if (!is_wall(*grid, coord) && !is_gap(*grid, coord)){
-                if (!is_relic(*grid, coord)) grid->tab[coord.lin][coord.col] = RELIC;
+        valid = 0;
+        while (!valid){
+            point = random_point(1, NB_COL - 2, 1, NB_LIN - 2);
+            resize_point(&point);
+            if (far_enough_from_the_player(point, &(*player))){
+                coord = point_case(point);
+                if (is_empty(*grid, coord)){
+                    grid->tab[coord.lin][coord.col] = RELIC;
+                    valid = 1;
+                }
             }
         }
     }
@@ -148,7 +130,118 @@ void place_manas_in_grid(Grid *grid){
     int i, j;
     for (i = 0; i < NB_LIN; i++){
         for (j = 0; j < NB_COL; j++){
-            if (grid->tab[i][j] == EMPTY) grid->tab[i][j] = MANA;
+            Case coord = {i, j};
+            if (is_empty(*grid, coord) || is_gap(*grid, coord)) grid->tab[i][j] = MANA;
+        }
+    }
+}
+
+
+/* Renvoie 1 si le gardien 'guard' touche ou se superpose à un autre gardien de 'tab' de taille 'size'.
+ * 'index' est l'indice du gardien 'guard' dans le tableau 'tab'.
+*/
+int superposition_between_guards(const Guard *guard, int index, const Guard *tab, int size){
+    int i;
+    for (i = 0; i < size; i++){
+        if (i != index && superposition_between_discs(guard->disc, tab[i].disc)) return 1;
+    }
+    return 0;
+}
+
+/* Renvoie 1 si le gardien 'guard' rentre dans un mur 
+ * possiblement situé sur l'une des 4 cases diagonales adjacentes à la sienne, 0 sinon 
+*/
+int in_diagonal_wall(const Guard *guard, Grid grid){
+    int i, j;
+    Case c_guard; /* Case contenant le centre du disque du gardien */
+    c_guard = point_case(guard->disc.center);
+
+    for (i = -1; i < 2; i++){
+        for (j = -1; j < 2; j++){
+            if (i != 0 && j != 0){
+                /* On ne veut que les cases situées sur les diagonales */
+                Case diagonal = {c_guard.lin + i, c_guard.col + j};
+
+                if (is_wall(grid, diagonal)){
+                    /* On veut le coin de case qui est commun à la case 'c_guard' et 'diagonal' */
+                    if (i == -1) diagonal.lin += 1;
+                    if (j == -1) diagonal.col += 1;
+                    Point corner = {diagonal.col, diagonal.lin};
+                    resize_point(&corner);
+                    /* Si ce coin est à l'intérieur du disque du gardien, alors 
+                    cela veut dire que le gardien rentre dans la case 'diagonal' */
+                    if (point_inside_disc(corner, guard->disc)) return 1;
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+/* Renvoie 1 si le gardien 'guard' rentre dans un mur ou une ouverture
+ * possiblement situé sur l'une des 4 cases latérales adjacentes à la sienne, 0 sinon 
+*/
+int in_lateral_wall_or_gap(const Guard *guard, Grid grid){
+    int i, j;
+    Case c_guard; /* Case contenant le centre du disque du gardien */
+    Point middle;
+    c_guard = point_case(guard->disc.center);
+    
+    /* Case en haut et en bas */
+    for (i = -1; i < 2; i++){
+        Case up_down = {c_guard.lin + i, c_guard.col};
+        if (i != 0 && (is_wall(grid, up_down) || is_gap(grid, up_down))){
+            middle.x = up_down.col + (1 / (double) 2);
+
+            if (i == -1) middle.y = up_down.lin + 1;
+            else if (i == 1) middle.y = up_down.lin;
+
+            resize_point(&middle);
+            if (point_inside_disc(middle, guard->disc)) return 1;
+        }
+    }
+    /* Case à gauche et à droite */
+    for (j = -1; j < 2; j++){
+        Case left_right = {c_guard.lin, c_guard.col + j};
+        if (j != 0 && (is_wall(grid, left_right) || is_gap(grid, left_right))){
+            middle.y = left_right.lin + (1 / (double) 2);
+
+            if (j == -1) middle.x = left_right.col + 1;
+            else if (j == 1) middle.x = left_right.col;
+
+            resize_point(&middle);
+            if (point_inside_disc(middle, guard->disc)) return 1;
+        }
+    }
+    return 0;
+}
+
+/* Place le gardien 'guard' dans la grille 'grid' assez loin du joueur 'player'
+ * et en prenant en compte les autres gardiens dans 'tab' de taille 'size'.
+ * 'index' est l'indice du gardien 'guard' dans le tableau 'tab'.
+*/
+void place_guard_in_grid(Guard *guard, int index, const Guard *tab, int size, Grid grid, const Player *player){
+    int valid;
+    Case coord;
+    Point point;
+    
+    valid = 0;
+    while (!valid){
+        point = random_point(1, NB_COL - 2, 1, NB_LIN - 2);
+        resize_point(&point);
+        if (far_enough_from_the_player(point, &(*player))){
+
+            coord = point_case(point);
+            if (!is_wall(grid, coord) && !is_gap(grid, coord)){
+
+                guard->disc.center.x = point.x;
+                guard->disc.center.y = point.y;
+                if (!superposition_between_guards(&(*guard), index, tab, size)){
+                    if (!in_diagonal_wall(&(*guard), grid)){
+                        if (!in_lateral_wall_or_gap(&(*guard), grid)) valid = 1;
+                    }
+                }
+            }
         }
     }
 }
\ No newline at end of file
diff --git a/Terrain.h b/Terrain.h
index 349f943..f1c5ea7 100644
--- a/Terrain.h
+++ b/Terrain.h
@@ -8,26 +8,30 @@
 #include "Guard.h"
 #define MINSIDE 9 /* Longueur minimale des côtés des compartiments crées */
 #define LENGTH_GAP 3 /* Taille d'une ouverture : 3 cases */
-#define INITIAL_POS_X 2.0 /* Coordonnée x de la position initiale du joueur */
-#define INITIAL_POS_Y 2.0 /* Coordonnée y de la position initiale du joueur */
-#define MIN_DIST 20 /* Distance euclidienne minimale qu'il doit y avoir entre 
-                     la position initiale du joueur et la position des gardiens et des reliques */
+#define INITIAL_POS_X 2.0 * SIZE_CASE /* Coordonnée x de la position initiale du joueur */
+#define INITIAL_POS_Y 2.0 * SIZE_CASE /* Coordonnée y de la position initiale du joueur */
+#define MINDIST 20 * SIZE_CASE /* Distance euclidienne minimale qu'il doit y avoir entre
+                                la position initiale du joueur et la position des gardiens et des reliques */
 
 
-void initialize_grid(Grid *grid);
-void show_grid(Grid grid);
 void generate_vertical_wall(Grid *grid, int column, int start_y, int end_y);
 void generate_horizontal_wall(Grid *grid, int line, int start_x, int end_x);
-int random_int(int a, int b);
 void random_position_for_wall(int *pos, int start, int end, int *left, int *right);
 void generate_compartments(Grid *grid, int x, int start_x, int end_x, int y, int start_y, int end_y);
 
 void place_player_in_grid(Player *player);
 
-int far_enough_from_the_player(Point point, Player player);
+int far_enough_from_the_player(Point point, const Player *player);
 int integer(double d);
 Case point_case(Point point);
-void place_relics_in_grid(int nb_relics, Grid *grid, Player player);
+void resize_point(Point *point);
+
+void place_relics_in_grid(int nb_relics, Grid *grid, const Player *player);
 void place_manas_in_grid(Grid *grid);
 
+int superposition_between_guards(const Guard *guard, int index, const Guard *tab, int size);
+int in_diagonal_wall(const Guard *guard, Grid grid);
+int in_lateral_wall_or_gap(const Guard *guard, Grid grid);
+void place_guard_in_grid(Guard *guard, int index, const Guard *tab, int size, Grid grid, const Player *player);
+
 #endif
\ No newline at end of file

commit fbf18ee40628ce8ac38c7634645040654b3efa83
Author: Sylvain Tran <sylvain.tran@etud.u-pem.fr>
Date:   Wed Jan 4 01:01:08 2023 +0100

    Création des modules Direction, Point, Disc, Player, Guard, Grid; Modification de Terrain : placement du joueur, des reliques et du mamas dans la salle

diff --git a/Direction.h b/Direction.h
new file mode 100644
index 0000000..4799d3a
--- /dev/null
+++ b/Direction.h
@@ -0,0 +1,11 @@
+#ifndef __DIRECTION__
+#define __DIRECTION__
+
+typedef enum{
+    UP,
+    DOWN,
+    LEFT,
+    RIGHT
+} Direction; /* Représente une direction */
+
+#endif
\ No newline at end of file
diff --git a/Disc.c b/Disc.c
new file mode 100644
index 0000000..cb53fd4
--- /dev/null
+++ b/Disc.c
@@ -0,0 +1,13 @@
+#include "Disc.h"
+#include <stdio.h>
+
+
+/* Renvoie 1 si les disques 'd1' et 'd2' se touchent ou se superposent, 0 sinon */
+int superposition_between_discs(Disc d1, Disc d2){
+    return distance(d1.center, d2.center) - d1.radius - d2.radius <= 0;
+}
+
+/* Renvoie 1 si le point 'a' est à l'intérieur du disque 'disc', 0 sinon */
+int point_inside_disc(Point a, Disc disc){
+    return distance(a, disc.center) < disc.radius;
+}
\ No newline at end of file
diff --git a/Disc.h b/Disc.h
new file mode 100644
index 0000000..d3ad078
--- /dev/null
+++ b/Disc.h
@@ -0,0 +1,14 @@
+#ifndef __DISC__
+#define __DISC__
+
+#include "Point.h"
+
+typedef struct{
+    Point center; /* Coordonnées du centre */
+    int radius; /* Rayon */
+} Disc; /* Représente un disque */
+
+int superposition_between_discs(Disc d1, Disc d2);
+int point_inside_disc(Point a, Disc disc);
+
+#endif
\ No newline at end of file
diff --git a/Grid.c b/Grid.c
new file mode 100644
index 0000000..5949834
--- /dev/null
+++ b/Grid.c
@@ -0,0 +1,18 @@
+#include "Grid.h"
+#include <stdio.h>
+
+
+/* Renvoie 1 si la case 'coord' de la grille est une case d'ouverture, 0 sinon */
+int is_gap(Grid grid, Case coord){
+    return grid.tab[coord.lin][coord.col] == GAP;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case de mur, 0 sinon */
+int is_wall(Grid grid, Case coord){
+    return grid.tab[coord.lin][coord.col] == WALL;
+}
+
+/* Renvoie 1 si la case 'coord' de la grille est une case de relique, 0 sinon */
+int is_relic(Grid grid, Case coord){
+    return grid.tab[coord.lin][coord.col] == RELIC;
+}
\ No newline at end of file
diff --git a/Grid.h b/Grid.h
new file mode 100644
index 0000000..b063d35
--- /dev/null
+++ b/Grid.h
@@ -0,0 +1,29 @@
+#ifndef __GRID__
+#define __GRID__
+
+#define NB_LIN 45 /* Hauteur de la grille */
+#define NB_COL 60 /* Longueur de la grille */
+#define SIZE_CASE 10 /* Longueur des côtés d'une case */
+
+typedef struct{
+    int lin, col;
+} Case; /* Représente une case de la grille */
+
+typedef enum{
+    EMPTY, /* Vide */
+    WALL, /* Mur */
+    GAP, /* Ouverture */
+    MANA, /* Traces de mana */
+    RELIC, /* Relique */
+    TAKE_RELIC /* Relique prise */
+} InfoCase; /* Donne une information sur une case */
+
+typedef struct{
+    InfoCase tab[NB_LIN][NB_COL];
+} Grid; /* Représente la grille du jeu */
+
+int is_gap(Grid grid, Case coord);
+int is_wall(Grid grid, Case coord);
+int is_relic(Grid grid, Case coord);
+
+#endif
\ No newline at end of file
diff --git a/Guard.h b/Guard.h
new file mode 100644
index 0000000..5f74b62
--- /dev/null
+++ b/Guard.h
@@ -0,0 +1,21 @@
+#ifndef __GUARD__
+#define __GUARD__
+
+#include "Point.h"
+#include "Disc.h"
+#include "Direction.h"
+
+typedef enum{
+    NORMAL,
+    PANIC
+} Mode;
+
+typedef struct{
+    Disc disc;
+    Mode mode;
+    Direction dir;
+    double speed;
+    int dist_detection;
+} Guard;
+
+#endif
\ No newline at end of file
diff --git a/Player.h b/Player.h
new file mode 100644
index 0000000..30dc793
--- /dev/null
+++ b/Player.h
@@ -0,0 +1,24 @@
+#ifndef __PLAYER__
+#define __PLAYER__
+
+#include "Point.h"
+#include "Disc.h"
+#include "Direction.h"
+
+typedef enum{
+    NONE,
+    ACCELERATION,
+    INVISIBILITY
+} Competence;
+
+typedef struct{
+    Disc disc;
+    Direction dir;
+    double speed, speed_max;
+    int mana;
+    Competence comp;
+} Player;
+
+void initialize_player(Player *player);
+
+#endif
\ No newline at end of file
diff --git a/Point.c b/Point.c
new file mode 100644
index 0000000..4edd317
--- /dev/null
+++ b/Point.c
@@ -0,0 +1,32 @@
+#include "Point.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#define SQUARE(x) ((x) * (x))
+
+
+/* Calcule la distance euclidienne entre les points 'a' et 'b' */
+double distance(Point a, Point b){
+    double dx, dy;
+    dx = b.x - a.x;
+    dy = b.y - a.y;
+    return sqrt(SQUARE(dx) + SQUARE(dy));
+}
+
+/* Renvoie un double aléatoire entre les entiers 'a' et 'b' (tous deux compris) */
+double random_double(int a, int b){
+    int n, nb_decimal;
+    nb_decimal = 1;
+    n = pow(10, nb_decimal);
+    a *= n;
+    b *= n;
+    return (rand() % (b - a + 1) + a) / (double) n;
+}
+
+/* Renvoie un point aléatoire.
+ * La coordonnée x (resp. y) du point est entre 'x1' et 'x2 (resp. 'y1' et 'y2').
+*/
+Point ramdom_point(int x1, int x2, int y1, int y2){
+    Point point = {random_double(x1, x2), random_double(y1, y2)};
+    return point;
+}
\ No newline at end of file
diff --git a/Point.h b/Point.h
new file mode 100644
index 0000000..5aa4070
--- /dev/null
+++ b/Point.h
@@ -0,0 +1,12 @@
+#ifndef __POINT__
+#define __POINT__
+
+typedef struct{
+    double x, y;
+} Point; /* Représente un point de coordonnées (x, y) */
+
+double distance(Point a, Point b);
+double random_double(int a, int b);
+Point ramdom_point(int x1, int x2, int y1, int y2);
+
+#endif
\ No newline at end of file
diff --git a/Terrain.c b/Terrain.c
index ea987af..dc08b2e 100644
--- a/Terrain.c
+++ b/Terrain.c
@@ -10,7 +10,7 @@ void initialize_grid(Grid *grid){
         for (j = 0; j < NB_COL; j++){
             /* Création des 4 murs extérieurs */
             if (i == 0 || i == NB_LIN - 1 || j == 0 || j == NB_COL - 1) grid->tab[i][j] = WALL;
-            else grid->tab[i][j] = NOTHING;
+            else grid->tab[i][j] = EMPTY;
         }
     }
 }
@@ -51,8 +51,8 @@ void generate_horizontal_wall(Grid *grid, int line, int start_x, int end_x){
     }
 }
 
-/* Renvoie un nombre aléatoire entre les entiers 'a' et 'b' (tous deux compris) */
-int rand_between_two_numbers(int a, int b){
+/* Renvoie un entier aléatoire entre les entiers 'a' et 'b' (tous deux compris) */
+int random_int(int a, int b){
     return rand() % (b - a + 1) + a;
 }
 
@@ -63,7 +63,7 @@ int rand_between_two_numbers(int a, int b){
 */
 void random_position_for_wall(int *pos, int start, int end, int *left, int *right){
     while (*left < MINSIDE || *right < MINSIDE){
-        *pos = rand_between_two_numbers(start, end);
+        *pos = random_int(start, end);
         *left = *pos - start;
         *right = end - *pos;
     }
@@ -99,4 +99,56 @@ void generate_compartments(Grid *grid, int x, int start_x, int end_x, int y, int
         generate_compartments(&(*grid), x, start_x, end_x, length_left, start_y, pos - 1);
         generate_compartments(&(*grid), x, start_x, end_x, length_right, pos + 1, end_y);
     }
+}
+
+
+/* Place le joueur dans la grille */
+void place_player_in_grid(Player *player){
+    player->disc.center.x = INITIAL_POS_X;
+    player->disc.center.y = INITIAL_POS_Y;
+}
+
+
+/* Renvoie 1 si le point 'point' est à une distance d'au moins MIN_DIST de la position du joueur 'player', 0 sinon */
+int far_enough_from_the_player(Point point, Player player){
+    return distance(point, player.disc.center) >= MIN_DIST;
+}
+
+/* Renvoie la partie entière de 'd' */
+int integer(double d){
+    return (int) d;
+}
+
+/* Renvoie la case contenant le point 'point' */
+Case point_case(Point point){
+    Case _case = {integer(point.y), integer(point.x)};
+    return _case;
+}
+
+/* Place 'nb_relics' reliques dans la grille 'grid' */
+void place_relics_in_grid(int nb_relics, Grid *grid, Player player){
+    int i;
+    Case coord;
+    Point point;
+
+    for (i = 0; i < nb_relics; i++){
+        point = ramdom_point(1, NB_COL - 2, 1, NB_COL - 2);
+
+        if (far_enough_from_the_player(point, player)){
+            coord = point_case(point);
+            if (!is_wall(*grid, coord) && !is_gap(*grid, coord)){
+                if (!is_relic(*grid, coord)) grid->tab[coord.lin][coord.col] = RELIC;
+            }
+        }
+    }
+}
+
+/* Place les cases de mana dans la grille 'grid' */
+void place_manas_in_grid(Grid *grid){
+    int i, j;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            if (grid->tab[i][j] == EMPTY) grid->tab[i][j] = MANA;
+        }
+    }
 }
\ No newline at end of file
diff --git a/Terrain.h b/Terrain.h
index 8d7e08f..349f943 100644
--- a/Terrain.h
+++ b/Terrain.h
@@ -1,29 +1,33 @@
 #ifndef __TERRAIN__
 #define __TERRAIN__
 
-#define NB_LIN 45 /* Hauteur de la grille */
-#define NB_COL 60 /* Longueur de la grille */
+#include "Grid.h"
+#include "Point.h"
+#include "Disc.h"
+#include "Player.h"
+#include "Guard.h"
 #define MINSIDE 9 /* Longueur minimale des côtés des compartiments crées */
 #define LENGTH_GAP 3 /* Taille d'une ouverture : 3 cases */
-#define SIDE_CASE 10 /* Longueur des côtés d'une case */
+#define INITIAL_POS_X 2.0 /* Coordonnée x de la position initiale du joueur */
+#define INITIAL_POS_Y 2.0 /* Coordonnée y de la position initiale du joueur */
+#define MIN_DIST 20 /* Distance euclidienne minimale qu'il doit y avoir entre 
+                     la position initiale du joueur et la position des gardiens et des reliques */
 
-typedef enum{
-    NOTHING, /* Rien */
-    WALL, /* Mur */
-    GAP, /* Ouverture */
-    MANA, /* Traces de mana */
-} Case; /* Représente une case de la grille */
-
-typedef struct{
-    Case tab[NB_LIN][NB_COL];
-} Grid; /* Représente la grille du jeu */
 
 void initialize_grid(Grid *grid);
 void show_grid(Grid grid);
 void generate_vertical_wall(Grid *grid, int column, int start_y, int end_y);
 void generate_horizontal_wall(Grid *grid, int line, int start_x, int end_x);
-int rand_between_two_numbers(int a, int b);
+int random_int(int a, int b);
 void random_position_for_wall(int *pos, int start, int end, int *left, int *right);
 void generate_compartments(Grid *grid, int x, int start_x, int end_x, int y, int start_y, int end_y);
 
+void place_player_in_grid(Player *player);
+
+int far_enough_from_the_player(Point point, Player player);
+int integer(double d);
+Case point_case(Point point);
+void place_relics_in_grid(int nb_relics, Grid *grid, Player player);
+void place_manas_in_grid(Grid *grid);
+
 #endif
\ No newline at end of file

commit 16822bfa7937f347b2c486be1f0887491437a82f
Author: Sylvain Tran <sylvain.tran@etud.u-pem.fr>
Date:   Mon Jan 2 20:50:39 2023 +0100

    Création du module Terrain : Subdivision de la salle en plusieurs compartiments

diff --git a/Terrain.c b/Terrain.c
new file mode 100644
index 0000000..ea987af
--- /dev/null
+++ b/Terrain.c
@@ -0,0 +1,102 @@
+#include "Terrain.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+
+/* Initialise la grille */
+void initialize_grid(Grid *grid){
+    int i, j;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            /* Création des 4 murs extérieurs */
+            if (i == 0 || i == NB_LIN - 1 || j == 0 || j == NB_COL - 1) grid->tab[i][j] = WALL;
+            else grid->tab[i][j] = NOTHING;
+        }
+    }
+}
+
+/* Affiche la grille */
+void show_grid(Grid grid){
+    int i, j;
+    for (i = 0; i < NB_LIN; i++){
+        for (j = 0; j < NB_COL; j++){
+            if (grid.tab[i][j] == WALL) printf("x");
+            else printf(" ");
+        }
+        printf("\n");
+    }
+}
+
+/* Génère un mur vertical dans la grille 'grid' de la ligne 'start_y' à la ligne 'end_y' à la colonne n°'column' */
+void generate_vertical_wall(Grid *grid, int column, int start_y, int end_y){
+    int i, alea;
+
+    alea = rand() % 2; /* Permet de savoir à quelle extrémité du mur les cases d'ouvertures doivent être placées */
+    for (i = start_y; i <= end_y; i++){
+        grid->tab[i][column] = WALL;
+        if (alea == 0 && i < start_y + LENGTH_GAP) grid->tab[i][column] = GAP;
+        if (alea == 1 && i > end_y - LENGTH_GAP) grid->tab[i][column] = GAP;
+    }
+}
+
+/* Génère un mur horizontal dans la grille 'grid' de la colonne 'start_x' à la colonne 'end_x' à la ligne n°'line' */
+void generate_horizontal_wall(Grid *grid, int line, int start_x, int end_x){
+    int i, alea;
+
+    alea = rand() % 2;
+    for (i = start_x; i <= end_x; i++){
+        grid->tab[line][i] = WALL;
+        if (alea == 0 && i < start_x + LENGTH_GAP) grid->tab[line][i] = GAP;
+        if (alea == 1 && i > end_x - LENGTH_GAP) grid->tab[line][i] = GAP;
+    }
+}
+
+/* Renvoie un nombre aléatoire entre les entiers 'a' et 'b' (tous deux compris) */
+int rand_between_two_numbers(int a, int b){
+    return rand() % (b - a + 1) + a;
+}
+
+/* Cherche aléatoirement un numéro de ligne ou colonne entre 'start' et 'end' pour savoir où placer un mur de façon 
+ * à ce que la taille (en longueur ou largeur) des deux compartiments crées à gauche et à droite soit plus grande que MINSIDE.
+ * On récupère via 'pos' la position de la ligne ou colonne où le mur sera généré.
+ * On récupère également au passage avec 'left' et 'right' la taille des compartiments gauche et droite crées
+*/
+void random_position_for_wall(int *pos, int start, int end, int *left, int *right){
+    while (*left < MINSIDE || *right < MINSIDE){
+        *pos = rand_between_two_numbers(start, end);
+        *left = *pos - start;
+        *right = end - *pos;
+    }
+}
+
+/* Subdivise la grille 'grid' en plusieurs compartiments dans l'espace libre de taille 'x' x 'y'.
+ * La longueur 'x' débute à la colonne 'start_x' et finit à la colonne 'end_x'.
+ * De même, la largeur 'y' débute à la ligne 'start_y' et finit à la ligne 'end_y'
+*/
+void generate_compartments(Grid *grid, int x, int start_x, int end_x, int y, int start_y, int end_y){
+    int pos;
+    int length_left = -1, length_right = -1;
+
+    if (x > y){
+        if (x < 2 * MINSIDE + 1) return;
+        else if (x < 4 * MINSIDE){
+            if (rand() % 2 == 0) return;   
+        }
+        random_position_for_wall(&pos, start_x, end_x, &length_left, &length_right);
+        generate_vertical_wall(&(*grid), pos, start_y, end_y);
+        /* On relance l'algo récursivement sur les deux compartiments générés */
+        generate_compartments(&(*grid), length_left, start_x, pos - 1, y, start_y, end_y);
+        generate_compartments(&(*grid), length_right, pos + 1, end_x, y, start_y, end_y);
+    }
+    else if (y > x){
+        if (y < 2 * MINSIDE + 1) return;
+        else if (y < 4 * MINSIDE){
+            if (rand() % 2 == 0) return;   
+        }
+        random_position_for_wall(&pos, start_y, end_y, &length_left, &length_right);
+        generate_horizontal_wall(&(*grid), pos, start_x, end_x);
+        /* On relance l'algo récursivement sur les deux compartiments générés */
+        generate_compartments(&(*grid), x, start_x, end_x, length_left, start_y, pos - 1);
+        generate_compartments(&(*grid), x, start_x, end_x, length_right, pos + 1, end_y);
+    }
+}
\ No newline at end of file
diff --git a/Terrain.h b/Terrain.h
new file mode 100644
index 0000000..8d7e08f
--- /dev/null
+++ b/Terrain.h
@@ -0,0 +1,29 @@
+#ifndef __TERRAIN__
+#define __TERRAIN__
+
+#define NB_LIN 45 /* Hauteur de la grille */
+#define NB_COL 60 /* Longueur de la grille */
+#define MINSIDE 9 /* Longueur minimale des côtés des compartiments crées */
+#define LENGTH_GAP 3 /* Taille d'une ouverture : 3 cases */
+#define SIDE_CASE 10 /* Longueur des côtés d'une case */
+
+typedef enum{
+    NOTHING, /* Rien */
+    WALL, /* Mur */
+    GAP, /* Ouverture */
+    MANA, /* Traces de mana */
+} Case; /* Représente une case de la grille */
+
+typedef struct{
+    Case tab[NB_LIN][NB_COL];
+} Grid; /* Représente la grille du jeu */
+
+void initialize_grid(Grid *grid);
+void show_grid(Grid grid);
+void generate_vertical_wall(Grid *grid, int column, int start_y, int end_y);
+void generate_horizontal_wall(Grid *grid, int line, int start_x, int end_x);
+int rand_between_two_numbers(int a, int b);
+void random_position_for_wall(int *pos, int start, int end, int *left, int *right);
+void generate_compartments(Grid *grid, int x, int start_x, int end_x, int y, int start_y, int end_y);
+
+#endif
\ No newline at end of file
